/*COMPILED*/





 /*JS File: ../js/ajaxanimator.js*/ 


 /**
 * Ajax Animator
 *
 * @author    Antimatter15
 * @copyright (c) 2007-2008, by Antimatter15
 * @date      14. April 2008
 * @version   0.20+ Testing
 *
 * @license application.js is licensed under the terms of the Open Source GPL 2.0 license. 
 * 
 * License details: http://www.gnu.org/licenses/gpl.html
 */
 
/*global Ext, Application */



Ext.ns('Ax'); //i got tired of typing ajaxanimator.xxx so i shortened it

Ax.animation = {
  name: "Untitled Production "+Math.floor(Math.random()*9999999),
  markup: {}
}
// application main entry point
Ext.onReady(function() {
  
  Ext.get("loading-msg").update("Initializing...")
   
  Ext.QuickTips.init();

 
    // code here
 
}); // eo function onReady
 
 
Ax.set_version = function(version_object){
  //Sets the current version of the applicaiton and does some operations with it
  
  Ax.v = version_object;
  
  if(window.developer==true){
    Ax.title = [Ax.v.app,Ax.v.release,Ax.v.stability,"Development"].join(" ");
  }else if(Ax.v.dev == true){
    Ax.title = [Ax.v.app,Ax.v.release,Ax.v.stability,"Testing build",Ax.v.build].join(" ");
  }else{
    Ax.title = [Ax.v.app,Ax.v.release,Ax.v.stability].join(" ");
  }
  
  document.title = Ax.title;
} 
 
// eof



 /*JS File: ../js/version.js*/ 


 /*Auto-Generated Ajax Animator Version config (Markup Version II)*/
/*Generated By versions.php in /server/dev/compile/*/
Ax.set_version( /*START*/
{"app":"Ajax Animator","build":773,"release":"0.20.06 Wave (bntr)","dev":false,"stability":"Beta","date":1325382208.9469}
/*STOP*/ )
/*End Of File*/



 /*JS File: ../js/misc/alt/files.js*/ 


 /*
 files and direcories used via ajax
 */

Ext.BLANK_IMAGE_URL = '../theme/images/default/s.gif';

Ax.files = {
/*
  xserv: "http://antimatter15.com/ajaxanimator/html/", //XS(S)ERV(er)/g
  //xss datastore
  xssds: (location.protocol=='file:'?'http:':location.protocol)+"//datastore-service.appspot.com/",
  xsave: (location.protocol=='file:'?'http:':location.protocol)+"//datastore-service.appspot.com/saveproxy",
  player: 'http://antimatter15.com/ajaxanimator/player/player.htm?',
    userlist: "../server/user/userlist.php",
	test: "../server/user/test.php",
    animations: "../server/user/animation.php?id=",
	library: "../server/user/library.php",
	libraryitem: "../server/user/libraryitem.php?id=",
    
    save_proxy: "../server/user/save_proxy.php",
    open_proxy: "../server/user/open_proxy.php",
	export_gif: "../server/export/gif.php",
	export_swf: "../server/export/swf.php",
	faq: "../server/doc/faq.htm",
	manual: "../server/doc/manual.htm",
*/	
	themes: "../theme/css/",
}




 /*JS File: ../js/wave.js*/ 


 //Wave2: A higher level abstraction of the Google Wave Gadget State API
//Features:
//  * With Hierarchy
//  * Shorter functions
//  * Event Listening

RegExp.escape = function(text) {
  if (!arguments.callee.sRE) {
    var specials = [
      '/', '.', '*', '+', '?', '|',
      '(', ')', '[', ']', '{', '}', '\\'
    ];
    arguments.callee.sRE = new RegExp(
      '(\\' + specials.join('|\\') + ')', 'g'
    );
  }
  return text.replace(arguments.callee.sRE, '\\$1');
}


var wave2 = {
  _evt: {},
  _bck: {},
  //_fastmask: {},
  _jcache: {}, //JSON CASH!
  _tcache: {},
  _state: {}, //for emulator
  fire_evt: true,
  mode: "wave" //wave or fake
}

wave2.index = function(v,a){
  for(var i=a.length;i--&&a[i]!=v;);
  return i
}

wave2.pseudowave = {
      subdelta: {},
      waiting: false,
      
      toString: function(){return Ext.util.JSON.encode(wave2._state)},

      clone: function(){
        //copy data fromr eal wave
        if(!wave2.fake()){
          //if real wave
          wave2.loop(function(key){
            var delta = {};
            delta[key] = wave2.get(key);
            wave2.pseudowave.submitDelta(delta)
          })(wave2.keys())
        }
      },
      
      submitDelta: function(d){
        for(var i in d){
          wave2.pseudowave.subdelta[i] = d[i];
        }
        wave2.pseudowave._coreDelta();
        //console.log("new delta",d)
        
      }, 
      _coreDelta: function(){
        if(!wave2.pseudowave.waiting){
          setTimeout(function(){
            for(var i in wave2.pseudowave.subdelta){
              if(wave2.pseudowave.subdelta[i] === null){
                delete wave2._state[i];
                //console.log("deleted",i,d[i],d)
              }else{
                //console.log("stored",i,d[i],d)
                wave2._state[i] = wave2.pseudowave.subdelta[i]
              }
            }
            wave2.pseudowave.subdelta = {};
            wave2.statechange()
            wave2.pseudowave.waiting = false;
          },200);
          wave2.pseudowave.waiting = true;
        }
      }, 
      
      get: function(name){
          return wave2._state[name]+''
          //console.log("get",name)
      }, getKeys: function(){
        var s = []
        for(var i in wave2._state){
          s.push(i)
        }
        return s;
      }}

wave2.nowave = function(){
/*
if (!window.developer) {
      if((wave2.lastalert-0) - (new Date).getTime() > 5000){
        wave2.lastalert = (new Date).getTime()
        Ax.toastMsg("Not In Google Wave","The application is not inside a Wave container, collaborative functions will not function.")
      }
    }
    */
}

wave2.fake = function(){
  if(wave2.mode == "wave"){
    if(window.wave && wave.getState()){
      return false
    }
    //wave2.nowave()
    return true
  }else{
    return true //fake!
  }
}

wave2.state = function(){
  if(wave2.fake()){
    wave2.nowave()
    return wave2.pseudowave
  }
  return wave.getState();
}

wave2.listen = function(event, callback, noupdate){
  if(event.pop){
    event = event.join("/")
  }
  if(!wave2._evt[event]){
    wave2._evt[event] = []
    if(!noupdate)wave2._update(event);
  }else if(wave2.index(callback,wave2._evt[event]) != -1){
    return false; 
  }
  
  wave2._evt[event].push(callback)
}

wave2.ignore = function(event, callback){
  if(event.pop){
    event = event.join("/")
  }
  if(!wave2._evt[event])return;
  var index = 0;
  while((index=wave2.index(callback, wave2._evt[event])) != -1){
    wave2._evt[event].splice(index, 1);
  }
  if(wave2._evt[event].length == 0){
    //do a bit of garbage collection
    var keys = wave2.subkeys(event, wave2._bck)
    for(var i = 0; i < keys.length; i++){
      delete wave2._bck[event+keys[i]]
    }
  }
}

wave2._keys = function(list){
  if(list === true){
    return wave2.keys(true); //you can probably tell now that this library is getting complicated and crappy
  }
  var s = []
  for(var i in list){
    s.push(i)
  }
  return s;
}

wave2._update = function(prefix){
  //console.log("update",prefix)
  var keys = wave2.subkeys(prefix)
  
  for(var i = 0; i < keys.length; i++){
    wave2._bck[prefix+keys[i]] = wave2.get(prefix+keys[i])
  }
}

wave2.keys = function(all){
  var keys = wave2.state().getKeys();
  if(!all){
    //filter through them
    for(var i = keys.length; i--;){
      if(wave2.get(keys[i]) === null){
        keys.splice(i,1)
      }
    }
  }
  
  return keys;
}

wave2.dump = function(){
  return wave2.state().toString()
}

wave2.subkeys = function(prefix, list){
  //var haslist = !!list;
  list=list?wave2._keys(list):wave2.keys();
  var subkeys = [];
  for(var i = 0, l = list.length; i < l; i++){
    if(list[i].indexOf(prefix) == 0){
      
      //if(haslist || wave2.get(prefix+list[i])){
        subkeys.push(list[i].substr(prefix.length))
      //}
    }
  }
  return subkeys;
}

wave2.expkeys = function(regex, list){
  list=list?list:wave2.keys();
  var subkeys = [];
  for(var i = 0, l = list.length; i < l; i++){
    if(list[i].match(regex)){
      subkeys.push(list[i])
    }
  }
  return subkeys;
}

wave2.set = function(name, value){
  if(name.pop){
    name = name.join("/")
  }
  var delta = {}
  delta[name] = value;
  var state = wave2.get(name), curstate = null;
  if(state === null){
    var curstate = wave2._get(name)
    if(typeof curstate == "string" && curstate.indexOf('DEL/') == 0){
    //oh noes i dont knows whats to dooz naw!
    if(parseInt(curstate.split('/')[1]) > (new Date).getTime() - (1337)){
      //OH NOES ITS NUUW!!
      //Ax.toastMsg("killed","DIE")
      return false; //DONT DO ANYTHIGN! STOPS IN URS TRAX!
    }
    }
  }
  if(state !== value){
    //console.log(name, value)
    wave2.state().submitDelta(delta)
  }
}

wave2._get = function(name){
  if(name.pop){
    name = name.join("/")
  }
  
  return /*wave2._fastmask[name]?wave2._fastmask[name]:*/wave2.state().get(name)
}

wave2.get = function(name){

  var state = wave2._get(name)
  
  if(!state){
      return null;
  }
  if(state.indexOf('DEL/') == 0){
    //oh noes it gots deletesed
    return null;
  }
  return state;
}

wave2.getJ = function(name){
  if(!wave2._jcache[name] || wave2.get(name) != wave2._tcache[name]){
    wave2._tcache[name] = wave2.get(name);
    wave2._jcache[name] = eval('('+wave2._tcache[name]+')');
  }
  return wave2._jcache[name]
}

wave2.me = function(){
  if(!wave2.fake()){
    return wave.getViewer().getId()
  }else{
    return "me@localhost.local"
  }
}

wave2.delta = function(delta){
  //for(var i in delta){
    //wave2._fastmask[i] = delta[i]
  //}
  return wave2.state().submitDelta(delta);
}

wave2.reset_gadget = function(){
  var state = {}, keys = wave2.keys()
  for(var i = 0; i < keys.length; i++){
    state[keys[i]] = wave2._delid();
  }
  wave2.delta(state)
}

wave2.del_subkeys = function(prefix){
  var keys = wave2.subkeys(prefix)
  var delta = {}
  for(var i = 0; i < keys.length; i++){
    delta[prefix+keys[i]] = wave2._delid();
  }
  wave2.delta(delta);
}

wave2.del_expkeys = function(regex){
  var keys = wave2.expkeys(regex)
  var delta = {}
  for(var i = 0; i < keys.length; i++){
    delta[keys[i]] =  wave2._delid();
  }
  wave2.delta(delta);
}

wave2.statechange = function(){
  //wave2._fastmask = {}; //reset fastmask
  var changed = false;
  var bckeys = [];
  var subkeys = [];
  for(var event in wave2._evt){
    subkeys = wave2.subkeys(event,true)
    bckeys = wave2.subkeys(event, wave2._bck)
    
    changed = false;
    for(var i = 0, k = subkeys.length; i < k;i++){
      var skey = event + subkeys[i]
      var val = wave2.get(skey);
      if(wave2._bck[skey]){
        if(wave2._bck[skey] !== val){
          if(wave2._get(skey).indexOf("DEL/") != 0){
            //modification
            changed = true
            wave2._bck[skey] = val;
            //console.log("change",skey)
          }else{
            //console.log("OHNOESDEL",skey,wave2._get(skey),wave2._bck[skey])
          }
        }
      }else{ //addition
        changed = true
        wave2._bck[skey] = val;
        //console.log("add",skey)
      }
    }
    for(var i = 0, k = bckeys.length; i < k;i++){
      var skey = event + bckeys[i]
      if(!wave2.get(skey)){ //deletion
        if(typeof wave2._get(skey) == "string" && wave2._get(skey).indexOf("DEL/") == 0){
          changed = true
          delete wave2._bck[skey];
        
          //schedule automatic garbage collection deletion
          
          
          //Ax.toastMsg("asdf",skey)
          //console.log('d',skey,wave2._get(skey))
        }
          //Ax.toastMsg("WTF","WTF",wave2._get(skey))
        //console.log("kill",skey)
      }
    }
    
    /*
    if(changed == false && subkeys.length != bckeys.length){
      Ax.toastMsg("Potential Sync Error","The wave synchronization encountered something strange. This should be ignorable.")
      //changed = true; //fallback
      wave2._update(event)
      //console.log("fallback",subkeys.length,bckeys.length,subkeys,bckeys, wave2.subkeys(event, wave2._bck))
    }*/
    //*/
    if(changed == true && wave2.fire_evt){
      for(var i = 0, s = wave2._evt[event].length; i < s;i++){
        //console.log(event, i, wave2._evt[event], subkeys)
        wave2._evt[event][i](wave2.subkeys(event))//(subkeys) //sorry, gots to do it again more restrictedly
        
      }
    }
  }
}

wave2.garbagecollect = function(force){
  /*
  var list = wave2.keys(true); //ALL YOUR O ARE BELONG TO US
  var state = {}
  for(var i = 0, l = list.length; i < l; i++){
    if(wave2._get(list[i]).indexOf("DEL/") == 0){
      if(parseInt(wave2._get(list[i]).split("/")[1]) < (new Date).getTime() - (1337*10) || force){
        state[list[i]] = null; //for real delete
        //console.log("blah")
      }
    }
  }
  wave2.delta(state);*/
}

wave2.del = function(name, no_mark){
  wave2.set(name, no_mark?null:wave2._delid())
}

wave2._delid = function(){
  return 'DEL/'+(new Date).getTime()
}

wave2.isPlayback = function(){
  //hack for the time being
  //return false;

  if(wave2.get("FORCE_OVERRIDE_PLAYBACK") == "TRUE"){
    return true;
  }
  if(!wave2.fake()){
    if((new Date).getTime()/1000 < 1254471241 + 592653){ //10 / 2 / 2009 @ 3:14 
      //wave is broken: this is a hack
      return wave.getState().get("${playback}");
    }
    
    return wave.isPlayback()
  }
  return false;
}

wave2.getParticipants = function(){
  if(!wave2.fake()){
    return wave.getParticipants()
  }
  return [];
}

wave2.loop = function(func){
  return function(subkeys){
    for(var i = 0; i < subkeys.length; i++){
      func(subkeys[i]);
    }
  }
}

function is_locked(name){
  //return index_of(name,get_subkeys("locked:")) != -1;
  //return wave2.me();
  /*
  var state = wave2.get(["l",Ax.tcurrent.frame,Ax.tcurrent.layer,name]);
  if(state == null){
    return false;
  }
  //never lock what is mine
  if(state.split("!t")[0] == wave2.me()){
    return false
  }
  //unlock if owner is dead.
  var people = wave2.getParticipants()
  for(var i = 0; i < people.length; i++){
    if(people[i].getId() == state.split("!t")[0]){
        if(parseInt(state.split("!t")[1]) > (new Date).getTime() - (1000*60)){
          return state.split("!t")[0]
        }else{
          return false;
        }
    }
  }*/
  return false
}



function lock_shape(name){
  //console.log("Locking:",name)
  //wave2.set(["l",Ax.tcurrent.frame,Ax.tcurrent.layer,name], wave2.me()+"!t"+(new Date).getTime());
  Ax.lastselect = (new Date).getTime();
}

function unlock_shape(name){  
  //console.log("Unlocking:",name)
  //wave2.del(["l",Ax.tcurrent.frame,Ax.tcurrent.layer,name]); //delete
  Ax.lastselect = (new Date).getTime();
}

Ax.wavesetup = (function(){
  var loop = wave2.loop;
  
  wave2.listen("m/", function(keys){
    //console.log(keys)
    var csizechanged = false;
    loop(function(key){
    
    var value = wave2.get("m/"+key)
    if(key == "canvasWidth"){
      Ax.canvasWidth = value;
      csizechanged = true;
    }else if(key == "canvasHeight"){
      Ax.canvasHeight = value;
      csizechanged = true;
    }else if(key == "framerate"){
      Ax.framerate = value;
    }
  })(keys)
  
  if(csizechanged == true){
    Ax.canvasSize();
  }
  
  },true)
  
  wave2.listen("k/", function(keys){
  //console.log(keys)
  //console.log("KF",keys)
  loop(function(key){
    key = key.split("/")
    frame = parseInt(key[0])
    layer = key[1]
    
    if(!Ax.layers[layer]){
      Ax.addLayer(layer);
    }
    
    if(!Ax.isKeyframe(frame, layer)){
      //Ax.msg("keyframe no reason","woot"+frame)
      Ax.toKeyframe(frame, layer,true)
    }
  })(keys)
  
  setTimeout(function(){
  for(var layer in Ax.layers){
    var keyframes = Ax.layers[layer].keyframes
    for(var i = 0; i < keyframes.length; i++){
      
      if(keyframes[i] == 1) continue; //frame 1 is something that i screwed up EERLY awn.
      //if(layer == Ax.tcurrent.layer && frame == Ax.tcurrent.frame) continue;
        
        //hak attak!
        //if(wave2.index(keyframes[i]+"/"+layer, keys) == -1){
        if(!wave2.get('k/'  +keyframes[i]+"/"+layer)){
          //Ax.msg("Deleting",keyframes[i]+"/"+layer)
          //console.log(keys,keyframes[i]+"/"+layer)
          Ax.deleteKeyframe(keyframes[i],layer,true)
        }
    }
  }
  },1337)
  
  },true)
  
  if (window.wave) {
    if(wave.isInWaveContainer()){
      wave.setStateCallback(wave2.statechange);
      wave.setModeCallback(Ax.wavemode);
    }else{
      wave2.nowave();
      Ext.MessageBox.alert("Wave Synchronization API Failed to Load",
      "The Wave Gadget API exists but can not connect to the Wave state server. "+
      "Reloading the wave may fix the issue, but until then the application will "+
      "likely be unusable. As far as I know, it's not my fault, but sorry anyway.")
    }
  }else{
    //wave2._state = {"c/~1/1/fie2":"{t:\"r\",id:\"fie2\",f:\"#FF0000\",fo:1,h:91,r:0,rx:0,ry:0,s:\"#000000\",so:1,sw:1,w:74,x:44,y:35.5,rt:0}","l/1/~1/fie2":"DEL/1254352459573","l/27/~1/fie2":"DEL/1254352463002","c/~1/27/fie2":"{t:\"r\",id:\"fie2\",f:\"#FF0000\",fo:1,h:91,r:0,rx:0,ry:0,s:\"#000000\",so:1,sw:1,w:74,x:426,y:130.5,rt:0}","k/27/~1":1}
    
    //wave2.statechange()
    
    wave2.nowave(); //nowave!
    wave2.mode = "fake"
  }
})

Ax.wavemode = function(mode_code){
  var mode = "UNKNOWN";
  switch (mode_code) {
    case wave.Mode.PLAYBACK: mode = "PLAYBACK"; break;
    case wave.Mode.EDIT: mode = "EDIT"; break;
    case wave.Mode.VIEW: mode = "VIEW"; break;
  }
  //Ax.msg("mode",mode)
  Ax.viewport.findById("maintabpanel").items.get(0).enable()
  if(mode == "EDIT"){
    Ax.viewport.findById("maintabpanel").activate(0)
  }
  if(mode == "VIEW" || mode == "PLAYBACK"){
    if(mode == "PLAYBACK"){
      Ax.viewport.findById("maintabpanel").items.get(0).disable()
    }
    Ax.viewport.findById("maintabpanel").activate(1)
  }
}

Ax.locklistener = null;
Ax.canvaslisteners = []
Ax.relisten = function(listen){
  
  if(Ax.locklistener){
    wave2.ignore(Ax.locklistener, Ax.lockchange);
  }
  Ax.locklistener = "l/"+Ax.tcurrent.frame+"/"+Ax.tcurrent.layer+'/';
  wave2.listen(Ax.locklistener, Ax.lockchange);
  
  for(var i = 0; i < Ax.canvaslisteners.length; i++){
    wave2.ignore(Ax.canvaslisteners[i], Ax.canvasrender);
    //wave2.listen("l/"+Ax.canvaslisteners[i].slice(1).reverse().join("/"), Ax.lockchange);
  }
  for(var i = 0; i < listen.length; i++){
    wave2.listen(listen[i], Ax.canvasrender);
    //wave2.listen("l/"+listen[i].slice(1).reverse().join("/"), Ax.lockchange);
  }
  Ax.canvaslisteners = listen;
}
Ax.canvasrender_queued = false;

Ax.lockui = [];

Ax.lockchange = function(change){
  //var keyimg = "http://ajaxanimator.googlecode.com/svn-history/r168/trunk/ajaxanimator/img/silk/key.png";
  //haack! move to Ax.files later?
  
  //Ax.msg("Changed Locks","Locks Changed")
  
  for(var i = 0; i < Ax.lockui.length; i++){
    Ax.lockui[i].remove()
  }
  Ax.lockui = [];
  
  wave2.loop(function(shape){
    //Ax.locklistener+shape
    var lock = is_locked(shape)
    if(Ax.canvas.getShapeById(shape) && lock){
      var bbox = Ax.canvas.getShapeById(shape).getBBox();
      //Ax.lockui.push(Ax.canvas.draw.image(keyimg,bbox.x+2,bbox.y+2,16,16))
      var text = Ax.canvas.draw.text(bbox.x,bbox.y+10,lock);
      var set = Ax.canvas.draw.set();
      var txb = text.getBBox() //i wish i knew a better way to align it like that
      text.attr("x", bbox.x + txb.width/2 + 8)
      txb = text.getBBox()
      set.push(Ax.canvas.draw.rect(txb.x-5, txb.y, txb.width+10, txb.height, 3)
        .attr("fill","#"+Ext.ux.Crypto.SHA1.hash(lock).substr(0,6)));
      text.toFront();
      set.push(text)
      set.toFront()
      Ax.lockui.push(set);
    }
  })(change)
  
  setTimeout(function(){
    for(var i = 0; i < Ax.lockui.length; i++){
      Ax.lockui[i].toFront();
    }
  },100)
}

Ax.canvasrender = function(){
  //alert("rerender!")
  //instead of complex diffing and other awesome stuff, just use the normal loadframe method
  //however you need to check to make sure that it's in an interruptable mode
  //hence this setTimeout
  if(!Ax.canvasrender_queued){
    
    //console.log(Ax.getcanvas(Ax.tcurrent.frame, Ax.tcurrent.layer));
        
    (function(){
      if(Ax.canvas.selected.length == 0 && (new Date).getTime() - Ax.lastselect > 1337){
        //TIME TO RELOAD DATS!
        //console.log("RELOADED")
        Ax.loadframe(Ax.tcurrent.frame, Ax.tcurrent.layer);
        Ax.canvasrender_queued = false;
      }else{
        //console.log("Quod Erat Demonstradum")
        Ax.canvasrender_queued = true;
        //stuff is selected! oh noes!
        setTimeout(arguments.callee, 100);  //is that a good rate?
      }
    })()
  }
}


Ax.small_json = function(obj){
  //simple JSON stringifier which creates small files
  //later if its still needed
  //mostly hackish as of now
  var nobj = {};
  for(var x in obj){
    //do hackishhack if its a legal name
    if(x.indexOf("-") == -1 && x.indexOf("!") == -1 && x.indexOf("/") == -1 && 
    x.indexOf("^") == -1 && x.indexOf("*") == -1 && x.indexOf("\\") == -1 && 
    x.indexOf(":") == -1 && x.indexOf("#") == -1 && x.indexOf("'") == -1 && 
    x.indexOf('"') == -1 && "0123456789".indexOf(x[0]) == -1){
      nobj["___"+x+"___"] = obj[x]
    }
  }
  var out = Ext.util.JSON.encode(nobj);
  out = out.replace(/___"/g, "");
  out = out.replace(/"___/g, "");
  return out;
}


Ax.inverse_map = function(map){
  var nmap = {};
  for(var key in map){
    nmap[map[key]] = key;
  }
  return nmap;
}

Ax.compress_map = {
      "height": "h",
      "width": "w",
      "fill-opacity": "fo",
      "stroke-opacity": "so",
      "fill": "f",
      "stroke": "s",
      "rotation": "rt",
      "type": "t",
      "stroke-width": "sw",
      "subtype": "st",
      "path": "p",
      "font-size": "fs",
      "text": "tx"
    }
    


Ax.type_map = {
  "ellipse": "e",
  "rect": "r",
  "image": "i",
  "text": "t",
  //RECYCLED FOR SUBTYPES TOO. SORTA HACKISH
  "line": "l",
  "path": "p", //brilliant multi-use
  "polygon": "py"
}


Ax.compress_attr = function(attr){
  //shrink the old IDs to soemthign smaller and more manageable
  if(attr.id && attr.id.indexOf("shape:") === 0){
    if("0123456789".indexOf(attr.id[0]) == -1){
      attr.id = attr.id.substr(6, 4);
    }else{
      attr.id = 's'+attr.id.substr(6, 3);
    }
  }
  
  
  var map = Ax.compress_map
  var type_map = Ax.type_map;
  
  var nosend = ["fillColor","lineColor","lineWidth"]
  
  
  //var rmdef = {
  /* //tweening doesn't take into account defaults. damnit.
    "fill-opacity": 1,
    "stroke-opacity": 1,
    "rotation": 0,
    "stroke-width": 1
  */
  //}
  var newattr = {};
  for(var i in attr){
    if(nosend.indexOf(i) == -1){
      if(map[i]){
        //if(rmdef[i] !== attr[i]){
          if((i == "type" || i == "subtype") && type_map[attr[i]]){
            newattr[map[i]] = type_map[attr[i]]
          }else if(i == "path"){
            newattr[map[i]] = attr[i].toString()
          }else{
            newattr[map[i]] = attr[i]
          }
        //}
      }else{
        newattr[i] = attr[i]
      }
    }
  }
  return newattr;
}

Ax.decompress_attr = function(attr){
  var map = Ax.compress_map
  var type_map = Ax.inverse_map(Ax.type_map)
  //var newattr = {};
  for(var i in map){
    if(attr[map[i]] !== null && attr[map[i]] !== undefined ){
      var val = attr[map[i]];
      if(i == "type" || i == "subtype"){
        if(type_map[val]){
          val = type_map[val];
        }
      }
      if(i == "path"){
        if(typeof val == "string"){
          val = Ax.parsePath(val);
        }
      }
      attr[i] = val;
      delete attr[map[i]];
    }
  }
  return attr;
}



 /*JS File: ../js/datastore.js*/ 


 function Datastore(group, service, proxy){
  this.group = group
  this.service = service?service:"http://datastore-service.appspot.com/?"
  this.proxy = proxy;
  this.cache = {};
}

Datastore.prototype.onmessage = function(data, callback){
  if(callback)callback(data);
  if(data.key) this.cache[data.key] = data; //if cachable then cache
}

Datastore.prototype.send = function(p, callback){
  var tc=this,param = "act="+encodeURIComponent(p.act)+
                            "&group="+encodeURIComponent(p.group)+
                            "&type="+encodeURIComponent(p.type)+
                            "&data="+encodeURIComponent(p.data)+
                            "&key="+encodeURIComponent(p.key)+
                            "&index="+encodeURIComponent(p.index)
  if(this.proxy){
    var x=this.ActiveXObject;x=new(x?x:XMLHttpRequest)('Microsoft.XMLHTTP');
    x.open('GET',this.service + param,1);
    x.onreadystatechange=function(){if(x.readyState>3){
      tc.onmessage(eval("("+x.responseText+")"), callback);
    }};x.send(d)
  }else{
    var s = document.createElement("script");
    var jsonp = "dsjp_"+Math.round(Math.random()*999999999);
    window[jsonp] = function(data){
      tc.onmessage(data,callback);
      document.body.removeChild(s);
    }
    s.type = "text/javascript"
    s.src = this.service + param + "&jsonp="+jsonp;
    document.body.appendChild(s);
  }
}

Datastore.prototype.setgroup = function(group){
  this.group = group;
}

Datastore.prototype.setservice = function(service){
  this.service = service;
}

Datastore.prototype.write = function(type, data, cbk){
  this.send({act: "write", group: this.group, type: type, data: data}, cbk)
}

Datastore.prototype.idx = function(type, index, cbk){ // get by index
  this.send({act: "idx", group: this.group, type: type, index: index}, cbk)
}


Datastore.prototype.ridx = function(type, index, cbk){ //get by reverse index
  this.send({act: "ridx", group: this.group, type: type, index: index}, cbk)
}

Datastore.prototype.first = function(type, cbk){
  this.ridx(type, 0, cbk);
}

Datastore.prototype.latest = function(type, cbk){
  this.idx(type, 0, cbk);
}

Datastore.prototype.listall = function(cbk){
  this.send({act: "all", group: this.group}, cbk)
}


Datastore.prototype.list = function(type, cbk){
  this.send({act: "list", group: this.group, type: type}, cbk)
}

Datastore.prototype.read = function(key, cbk){
  if(this.cache[key]) return this.onmessage(this.cache[key],cbk);
  this.send({act: "read", key: key}, cbk);
}



 /*JS File: ../js/ext/ux/Ext.ux.base64.js*/ 


 
Ext.ux.base64 = {

    base64s : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    
    encode: function(decStr){
        if (typeof btoa === 'function') {
             return btoa(decStr);            
        }
        var base64s = this.base64s;
        var bits;
        var dual;
        var i = 0;
        var encOut = "";
        while(decStr.length >= i + 3){
            bits = (decStr.charCodeAt(i++) & 0xff) <<16 | (decStr.charCodeAt(i++) & 0xff) <<8 | decStr.charCodeAt(i++) & 0xff;
            encOut += base64s.charAt((bits & 0x00fc0000) >>18) + base64s.charAt((bits & 0x0003f000) >>12) + base64s.charAt((bits & 0x00000fc0) >> 6) + base64s.charAt((bits & 0x0000003f));
        }
        if(decStr.length -i > 0 && decStr.length -i < 3){
            dual = Boolean(decStr.length -i -1);
            bits = ((decStr.charCodeAt(i++) & 0xff) <<16) |    (dual ? (decStr.charCodeAt(i) & 0xff) <<8 : 0);
            encOut += base64s.charAt((bits & 0x00fc0000) >>18) + base64s.charAt((bits & 0x0003f000) >>12) + (dual ? base64s.charAt((bits & 0x00000fc0) >>6) : '=') + '=';
        }
        return(encOut);
    },
    
    decode: function(encStr){
        if (typeof atob === 'function') {
            return atob(encStr); 
        }
        var base64s = this.base64s;        
        var bits;
        var decOut = "";
        var i = 0;
        for(; i<encStr.length; i += 4){
            bits = (base64s.indexOf(encStr.charAt(i)) & 0xff) <<18 | (base64s.indexOf(encStr.charAt(i +1)) & 0xff) <<12 | (base64s.indexOf(encStr.charAt(i +2)) & 0xff) << 6 | base64s.indexOf(encStr.charAt(i +3)) & 0xff;
            decOut += String.fromCharCode((bits & 0xff0000) >>16, (bits & 0xff00) >>8, bits & 0xff);
        }
        if(encStr.charCodeAt(i -2) == 61){
            return(decOut.substring(0, decOut.length -2));
        }
        else if(encStr.charCodeAt(i -1) == 61){
            return(decOut.substring(0, decOut.length -1));
        }
        else {
            return(decOut);
        }
    }

}; 







 /*JS File: ../js/ext/ux/Ext.ux.clone.js*/ 


 /**
 * Clone Function
 */

Ext.ux.clone = function(o) {
    if(!o || 'object' !== typeof o) {
        return o;
    }
    var c = 'function' === typeof o.pop ? [] : {};
    var p, v;
    for(p in o) {
        if(o.hasOwnProperty(p)) {
            v = o[p];
            if(v && 'object' === typeof v) {
                c[p] = Ext.ux.clone(v);
            }
            else {
                c[p] = v;
            }
        }
    }
    return c;
}; // eo function clone 



 /*JS File: ../js/ext/ux/Ext.ux.Crypto.SHA1.js*/ 


 Ext.namespace('Ext.ux', 'Ext.ux.Crypto');

Ext.ux.Crypto.SHA1 = function() {
  // function 'f' [ß4.1.1]
  var f = function(s, x, y, z) {
      switch (s) {
          case 0: return (x & y) ^ (~x & z);           // Ch()
          case 1: return x ^ y ^ z;                    // Parity()
          case 2: return (x & y) ^ (x & z) ^ (y & z);  // Maj()
          case 3: return x ^ y ^ z;                    // Parity()
      }
  };
  // rotate left (circular left shift) value x by n positions [ß3.2.5]
  var ROTL = function(x, n) {
      return (x<<n) | (x>>>(32-n));
  };
  return {
    hash : function(msg) {
      // constants [ß4.2.1]
      var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  
  
      // PREPROCESSING 
   
      msg += String.fromCharCode(0x80); // add trailing '1' bit to string [ß5.1.1]
  
      // convert string msg into 512-bit/16-integer blocks arrays of ints [ß5.2.1]
      var l = Math.ceil(msg.length/4) + 2;  // long enough to contain msg plus 2-word length
      var N = Math.ceil(l/16);              // in N 16-int blocks
      var M = new Array(N);
      for (var i=0; i<N; i++) {
          M[i] = new Array(16);
          for (var j=0; j<16; j++) {  // encode 4 chars per integer, big-endian encoding
              M[i][j] = (msg.charCodeAt(i*64+j*4)<<24) | (msg.charCodeAt(i*64+j*4+1)<<16) | 
                        (msg.charCodeAt(i*64+j*4+2)<<8) | (msg.charCodeAt(i*64+j*4+3));
          }
      }
      // add length (in bits) into final pair of 32-bit integers (big-endian) [5.1.1]
      // note: most significant word would be ((len-1)*8 >>> 32, but since JS converts
      // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators
      M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14])
      M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;
  
      // set initial hash value [ß5.3.1]
      var H0 = 0x67452301;
      var H1 = 0xefcdab89;
      var H2 = 0x98badcfe;
      var H3 = 0x10325476;
      var H4 = 0xc3d2e1f0;
  
      // HASH COMPUTATION [ß6.1.2]
  
      var W = new Array(80); var a, b, c, d, e;
      for (var i=0; i<N; i++) {
  
          // 1 - prepare message schedule 'W'
          for (var t=0;  t<16; t++) W[t] = M[i][t];
          for (var t=16; t<80; t++) W[t] = ROTL(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16], 1);
  
          // 2 - initialise five working variables a, b, c, d, e with previous hash value
          a = H0; b = H1; c = H2; d = H3; e = H4;
  
          // 3 - main loop
          for (var t=0; t<80; t++) {
              var s = Math.floor(t/20); // seq for blocks of 'f' functions and 'K' constants
              var T = (ROTL(a,5) + f(s,b,c,d) + e + K[s] + W[t]) & 0xffffffff;
              e = d;
              d = c;
              c = ROTL(b, 30);
              b = a;
              a = T;
          }
  
          // 4 - compute the new intermediate hash value
          H0 = (H0+a) & 0xffffffff;  // note 'addition modulo 2^32'
          H1 = (H1+b) & 0xffffffff; 
          H2 = (H2+c) & 0xffffffff; 
          H3 = (H3+d) & 0xffffffff; 
          H4 = (H4+e) & 0xffffffff;
      }
  
      return H0.toHexStr() + H1.toHexStr() + H2.toHexStr() + H3.toHexStr() + H4.toHexStr();
    }
  }
  
}();

/**
 * @class Number
 */
Ext.applyIf(Number.prototype, {
    /**
     * extend Number class with a tailored hex-string method (note toString(16) is implementation-dependant, and in IE returns signed numbers when used on full words)
     * @return {String} The number in Hexidecimal format.
     */
    toHexStr : function(){
        var s = '', v;
        for(var i = 7; i >= 0; i--) {
            v = (this >>> (i * 4)) & 0xf;
            s += v.toString(16);
        }
        return s;
    }
});



 /*JS File: ../js/ext/ux/Ext.ux.ThemeMenu.js*/ 


 /*
* Theme Selection Menu
*
* By Antimatter15 2008
* i donno. gpl v3 maybe.
*/

Ext.ux.ThemeMenu = function(config){
    Ext.ux.ThemeMenu.superclass.constructor.call(this, config);

    //this.plain = true;
	for(var theme = 0; theme < this.themeconfig.length; theme++){
	this.add(new Ext.menu.CheckItem({
    text: this.themeconfig[theme][1], //text title
	theme: theme,
	checked: (this.themeconfig[theme][2]==true),
    group: 'thememenu',
    checkHandler: function(item, checked) {
        if (checked){
		item.parentMenu.setTheme(item.theme)
		};
    }
}))
}

};

Ext.extend(Ext.ux.ThemeMenu, Ext.menu.Menu, {

cssPath: Ax.files.themes, //mind the trailing slash

themeconfig:[ //array of stuff
 ['xtheme-default.css','Ext Blue Theme',true] //t3h default
,['xtheme-gray.css', 'Gray Theme']
,['xtheme-gray.css,xtheme-gray-extend.css', 'Extended Gray Theme'] //this is an "extend" theme, it is applied over another theme
,['xtheme-darkgray.css', 'Dark Gray Theme']
,['xtheme-black.css',  'Black Theme']
,['xtheme-olive.css', 'Olive Theme']
,['xtheme-purple.css', 'Purple Theme']
,['xtheme-slate.css', 'Slate Theme']
,['xtheme-peppermint.css',  'Peppermint Theme']
,['xtheme-chocolate.css', 'Chocolate Theme']
,['xtheme-slickness.css', 'SlicknesS Theme']
,['xtheme-pink.css', 'Pink Theme']
,['xtheme-midnight.css', "Midnight Theme"]
,['xtheme-green.css', "Green Theme"]
,['xtheme-indigo.css', "Indigo Theme"]
,['xtheme-silverCherry.css',"Silver Cherry Theme"]
,['xtheme-orange.css',"Orange Theme"]
],
setTheme: function(id){
//console.log(this)
var theme = this.themeconfig[id][0];
var themes = theme.split(",")
for(var i = 0; i < 4; i++){ //up to 4 themes on top of each other
if(themes[i]){
Ext.util.CSS.swapStyleSheet('csstheme'+i, this.cssPath + themes[i]);
}else{
Ext.util.CSS.removeStyleSheet('csstheme'+i);
}
}

}//end setTheme
});









 /*JS File: ../js/ext/ux/Ext.ux.ToastWindow.js*/ 


 Ext.ux.ToastWindowMgr = {
    positions: [] 
};

Ext.ux.ToastWindow = Ext.extend(Ext.Window, {
    initComponent: function(){
          Ext.apply(this, {
            iconCls: this.iconCls || 'information',
            width: 200,
            height: 100,
			delay: this.delay?this.delay:4000,
            autoScroll: true,
            autoDestroy: true,
            plain: false
          });
        this.task = new Ext.util.DelayedTask(this.hide, this);
        Ext.ux.ToastWindow.superclass.initComponent.call(this);
		
		//console.log(this.delay)
    },
    setMessage: function(msg){
        this.body.update(msg);
    },
    setTitle: function(title, iconCls){
        Ext.ux.ToastWindow.superclass.setTitle.call(this, title, iconCls||this.iconCls);
    },
    onRender:function(ct, position) {
        Ext.ux.ToastWindow.superclass.onRender.call(this, ct, position);
    },
    onDestroy: function(){
        Ext.ux.ToastWindowMgr.positions.remove(this.pos);
        Ext.ux.ToastWindow.superclass.onDestroy.call(this);
    },
    afterShow: function(){
        Ext.ux.ToastWindow.superclass.afterShow.call(this);
        this.on('move', function(){
               Ext.ux.ToastWindowMgr.positions.remove(this.pos);
            this.task.cancel();}
        , this);
        this.task.delay(this.delay);
    },
    animShow: function(){
        this.pos = 0;
        while(Ext.ux.ToastWindowMgr.positions.indexOf(this.pos)>-1)
            this.pos++;
        Ext.ux.ToastWindowMgr.positions.push(this.pos);
        this.setSize(200,100);
        this.el.alignTo(document, "br-br", [ -20, -20-((this.getSize().height+10)*this.pos) ]);
        this.el.slideIn('b', {
            duration: 1,
            callback: this.afterShow,
            scope: this
        });    
    },
    animHide: function(){
        Ext.ux.ToastWindowMgr.positions.remove(this.pos);
        this.el.ghost("b", {
            duration: 1,
            remove: true,
        	scope: this,
        	callback: this.destroy
        });
    },
	  focus: Ext.emptyFn 

});  


 /*JS File: ../js/ext/ux/Ext.ux.grid.CellActions.js*/ 


 // vim: ts=4:sw=4:nu:fdc=4:nospell
/**
 * CellActions plugin for Ext grid
 *
 * Contains renderer for an icon and fires events when icon is clicked
 *
 * @author    Ing. Jozef Sak√°lo≈°
 * @date      22. March 2008
 * @version   $Id: Ext.ux.grid.CellActions.js 163 2008-06-18 17:24:54Z antimatter15 $
 *
 * @license Ext.ux.grid.CellActions is licensed under the terms of
 * the Open Source LGPL 3.0 license.  Commercial use is permitted to the extent
 * that the code/component(s) do NOT become part of another Open Source or Commercially
 * licensed development library or toolkit without explicit permission.
 * 
 * License details: http://www.gnu.org/licenses/lgpl.html
 */

/**
 * The following css is required:
 *
 * .ux-cell-value {
 * 	position:relative;
 * 	zoom:1;
 * }
 * .ux-cell-actions {
 * 	position:absolute;
 * 	right:0;
 * 	top:-2px;
 * }
 * .ux-cell-actions-left {
 * 	left:0;
 * 	top:-2px;
 * }
 * .ux-cell-action {
 * 	width:16px;
 * 	height:16px;
 * 	float:left;
 * 	cursor:pointer;
 * 	margin: 0 0 0 4px;
 * }
 * .ux-cell-actions-left .ux-cell-action {
 * 	margin: 0 4px 0 0;
 * }
 */

/*global Ext */

Ext.ns('Ext.ux.grid');

// constructor and cellActions documentation
// {{{
/**
 * @class Ext.ux.grid.CellActions
 * @extends Ext.util.Observable
 * @constructor
 *
 * CellActions plugin causes that column model recognizes the config property cellAcions
 * that is the array of configuration objects for that column. The documentationi follows.
 *
 * THE FOLLOWING CONFIG OPTIONS ARE FOR COLUMN MODEL COLUMN, NOT FOR CellActions ITSELF.
 *
 * @cfg {Array} cellActions Mandatory. Array of action configuration objects. The following
 * configuration options of action are recognized:
 *
 * - @cfg {Function} callback Optional. Function to call if the action icon is clicked.
 *   This function is called with same signature as action event and in its original scope.
 *   If you need to call it in different scope or with another signature use 
 *   createCallback or createDelegate functions. Works for statically defined actions. Use
 *   callbacks configuration options for store bound actions.
 *
 * - @cfg {Function} cb Shortcut for callback.
 *
 * - @cfg {String} iconIndex Optional, however either iconIndex or iconCls must be
 *   configured. Field name of the field of the grid store record that contains
 *   css class of the icon to show. If configured, shown icons can vary depending
 *   of the value of this field.
 *
 * - @cfg {String} iconCls. css class of the icon to show. It is ignored if iconIndex is
 *   configured. Use this if you want static icons that are not base on the values in the record.
 *
 * - @cfg {String} qtipIndex Optional. Field name of the field of the grid store record that 
 *   contains tooltip text. If configured, the tooltip texts are taken from the store.
 *
 * - @cfg {String} tooltip Optional. Tooltip text to use as icon tooltip. It is ignored if 
 *   qtipIndex is configured. Use this if you want static tooltips that are not taken from the store.
 *
 * - @cfg {String} qtip Synonym for tooltip
 *
 * - @cfg {String} style Optional. Style to apply to action icon container.
 */
Ext.ux.grid.CellActions = function(config) {
	Ext.apply(this, config);

	this.addEvents(
		/**
		 * @event action
		 * Fires when user clicks a cell action
		 * @param {Ext.grid.GridPanel} grid
		 * @param {Ext.data.Record} record Record containing data of clicked cell
		 * @param {String} action Action clicked (equals iconCls);
		 * @param {Mixed} value Value of the clicke cell
		 * @param {String} dataIndex as specified in column model
		 * @param {Number} rowIndex Index of row clicked
		 * @param {Number} colIndex Incex of col clicked
		 */
		'action'
		/**
		 * @event beforeaction
		 * Fires when user clicks a cell action but before action event is fired. Return false to cancel the action;
		 * @param {Ext.grid.GridPanel} grid
		 * @param {Ext.data.Record} record Record containing data of clicked cell
		 * @param {String} action Action clicked (equals iconCls);
		 * @param {Mixed} value Value of the clicke cell
		 * @param {String} dataIndex as specified in column model
		 * @param {Number} rowIndex Index of row clicked
		 * @param {Number} colIndex Incex of col clicked
		 */
		,'beforeaction'
	);
	// call parent
	Ext.ux.grid.CellActions.superclass.constructor.call(this);

}; // eo constructor
// }}}

Ext.extend(Ext.ux.grid.CellActions, Ext.util.Observable, {

	/**
	 * @cfg {String} actionEvnet Event to trigger actions, e.g. click, dblclick, mouseover (defaults to 'click')
	 */
	 actionEvent:'click'

	/**
	 * @cfg {Number} actionWidth Width of action icon in pixels. Has effect only if align:'left'
	 */
	,actionWidth:20

	/**
	 * @cfg {String} align Set to 'left' to put action icons before the cell text. (defaults to undefined, meaning right)
	 */

	/**
	 * @private
	 * @cfg {String} tpl Template for cell with actions
	 */
	,tpl:'<div class="ux-cell-value" style="padding-left:{padding}px">'
			+'<tpl if="\'left\'!==align">{value}</tpl>'
		 	+'<div class="ux-cell-actions<tpl if="\'left\'===align"> ux-cell-actions-left</tpl>" style="width:{width}px">'
				+'<tpl for="actions"><div class="ux-cell-action {cls}" qtip="{qtip}" style="{style}">&#160;</div></tpl>'
			+'</div>'
			+'<tpl if="\'left\'===align">{value}</tpl>'
		+'<div>'
		
	/**
	 * Called at the end of processActions. Override this if you need it.
	 * @param {Object} c Column model configuration object
	 * @param {Object} data See this.processActions method for details
	 */
	,userProcessing:Ext.emptyFn

	// {{{
	/**
	 * Init function
	 * @param {Ext.grid.GridPanel} grid Grid this plugin is in
	 */
	,init:function(grid) {
		this.grid = grid;
//		grid.on({scope:this, render:this.onRenderGrid});
		grid.afterRender = grid.afterRender.createSequence(this.onRenderGrid, this);

		var cm = this.grid.getColumnModel();
		Ext.each(cm.config, function(c, idx) {
			if('object' === typeof c.cellActions) {
				c.origRenderer = cm.getRenderer(idx);
				c.renderer = this.renderActions.createDelegate(this);
			}
		}, this);


	} // eo function init
	// }}}
	// {{{
	/**
	 * grid render event handler, install actionEvent handler on view.mainBody
	 * @private
	 */
	,onRenderGrid:function() {

		// install click event handler on view mainBody
		this.view = this.grid.getView();
		var cfg = {scope:this};
		cfg[this.actionEvent] = this.onClick;
		this.view.mainBody.on(cfg);

	} // eo function onRender
	// }}}
	// {{{
	/**
	 * Returns data to apply to template. Override this if needed
	 * @param {Mixed} value 
	 * @param {Object} cell object to set some attributes of the grid cell
	 * @param {Ext.data.Record} record from which the data is extracted
	 * @param {Number} row row index
	 * @param {Number} col col index
	 * @param {Ext.data.Store} store object from which the record is extracted
	 * @returns {Object} data to apply to template
	 */
	,getData:function(value, cell, record, row, col, store) {
		return record.data || {};
	}
	// }}}
	// {{{
	/**
	 * replaces (but calls) the original renderer from column model
	 * @private
	 * @param {Mixed} value 
	 * @param {Object} cell object to set some attributes of the grid cell
	 * @param {Ext.data.Record} record from which the data is extracted
	 * @param {Number} row row index
	 * @param {Number} col col index
	 * @param {Ext.data.Store} store object from which the record is extracted
	 * @returns {String} markup of cell content
	 */
	,renderActions:function(value, cell, record, row, col, store) {

		// get column config from column model
		var c = this.grid.getColumnModel().config[col];

		// get output of the original renderer
		var val = c.origRenderer(value, cell, record, row, col, store);

		// get actions template if we need but don't have one
		if(c.cellActions && !c.actionsTpl) {
			c.actionsTpl = this.processActions(c);
			c.actionsTpl.compile();
		}
		// return original renderer output if we don't have actions
		else if(!c.cellActions) {
			return val;
		}

		// get and return final markup
		var data = this.getData.apply(this, arguments);
		data.value = val;
		return c.actionsTpl.apply(data);

	} // eo function renderActions
	// }}}
	// {{{
	/**
	 * processes the actions configs from column model column, saves callbacks and creates template
	 * @param {Object} c column model config of one column
	 * @private
	 */
	,processActions:function(c) {

		// callbacks holder
		this.callbacks = this.callbacks || {};

		// data for intermediate template
		var data = {
			 align:this.align || 'right'
			,width:this.actionWidth * c.cellActions.length
			,padding:'left' === this.align ? this.actionWidth * c.cellActions.length : 0
			,value:'{value}'
			,actions:[]
		};

		// cellActions loop
		Ext.each(c.cellActions, function(a, i) {

			// save callback
			if(a.iconCls && 'function' === typeof (a.callback || a.cb)) {
				this.callbacks[a.iconCls] = a.callback || a.cb;
			}

			// data for intermediate xtemplate action
			var o = {
				 cls:a.iconIndex ? '{' + a.iconIndex + '}' : (a.iconCls ? a.iconCls : '')
				,qtip:a.qtipIndex ? '{' + a.qtipIndex + '}' : (a.tooltip || a.qtip ? a.tooltip || a.qtip : '')
				,style:a.style ? a.style : ''
			};
			data.actions.push(o);

		}, this); // eo cellActions loop

		this.userProcessing(c, data);

		// get and return final template
		var xt = new Ext.XTemplate(this.tpl);
		return new Ext.Template(xt.apply(data));

	} // eo function processActions
	// }}}
	// {{{
	/**
	 * Grid body actionEvent event handler
	 * @private
	 */
	,onClick:function(e, target) {

		// collect all variables for callback and/or events
		var t = e.getTarget('div.ux-cell-action');
		var row = e.getTarget('.x-grid3-row');
		var col = this.view.findCellIndex(target.parentNode.parentNode);
		var c = this.grid.getColumnModel().config[col];
		var record, dataIndex, value, action;
		if(t) {
			record = this.grid.store.getAt(row.rowIndex);
			dataIndex = c.dataIndex;
			value = record.get(dataIndex);
			action = t.className.replace(/ux-cell-action /, '');
		}

		// check if we've collected all necessary variables
		if(false !== row && false !== col && record && dataIndex && action) {

			// call callback if any
			if(this.callbacks && 'function' === typeof this.callbacks[action]) {
				this.callbacks[action](this.grid, record, action, value, row.rowIndex, col);
			}

			// fire events
			if(true !== this.eventsSuspended && false === this.fireEvent('beforeaction', this.grid, record, action, value, dataIndex, row.rowIndex, col)) {
				return;
			}
			else if(true !== this.eventsSuspended) {
				this.fireEvent('action', this.grid, record, action, value, dataIndex, row.rowIndex, col);
			}

		}
	} // eo function onClick
	// }}}

});

// register xtype
Ext.reg('cellactions', Ext.ux.grid.CellActions);

// eof



 /*JS File: ../js/ext/ux/Ext.ux.SliderTip.js*/ 


 /**
 * @class Ext.ux.SliderTip
* @extends Ext.Tip
 * Simple plugin for using an Ext.Tip with a slider to show the slider value
 * stolen from the Ext Slider Example http://extjs.com/deploy/dev/examples/slider/slider.html
 */
 
Ext.ux.SliderTip = Ext.extend(Ext.Tip, {
 minWidth: 10,
 offsets : [0, -10],
 init : function(slider){
 slider.on('dragstart', this.onSlide, this);
 slider.on('drag', this.onSlide, this);
 slider.on('dragend', this.hide, this);
 slider.on('destroy', this.destroy, this);
 },

 onSlide : function(slider){
 this.show();
 this.body.update(this.getText(slider));
 this.doAutoWidth();
 this.el.alignTo(slider.thumb, 'b-t?', this.offsets);
 },

 getText : function(slider){
 return slider.getValue();
 }
});


 /*JS File: ../js/ext/ux/Ext.ux.ColorField.js*/ 


 /**
 * @class Ext.ux.ColorField
 * @extends Ext.form.TriggerField
 * Provides a very simple color form field with a ColorMenu dropdown.
 * Values are stored as a six-character hex value without the '#'.
 * I.e. 'ffffff'
 * @constructor
 * Create a new ColorField
 * <br />Example:
 * <pre><code>
var cf = new Ext.ux.ColorField({
	fieldLabel: 'Color',
	hiddenName:'pref_sales',
	showHexValue:true
});
</code></pre>
 * @param {Object} config
 */
 
Ext.ux.ColorField = function(config){
    Ext.ux.ColorField.superclass.constructor.call(this, config);
	this.on('render', this.handleRender);
};

Ext.extend(Ext.ux.ColorField, Ext.form.TriggerField,  {
   initComponent: function(){
    this.addEvents({
      "select": true
    })
   },
    /**
     * @cfg {Boolean} showHexValue
     * True to display the HTML Hexidecimal Color Value in the field
     * so it is manually editable.
     */
    showHexValue : false,
	
	/**
     * @cfg {String} triggerClass
     * An additional CSS class used to style the trigger button.  The trigger will always get the
     * class 'x-form-trigger' and triggerClass will be <b>appended</b> if specified (defaults to 'x-form-color-trigger'
     * which displays a calendar icon).
     */
    triggerClass : 'x-form-color-trigger',
	
    /**
     * @cfg {String/Object} autoCreate
     * A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "input", type: "text", size: "10", autocomplete: "off"})
     */
    // private
    defaultAutoCreate : {tag: "input", type: "text", size: "10",
						 autocomplete: "off", maxlength:"6"},
	
	/**
	 * @cfg {String} lengthText
	 * A string to be displayed when the length of the input field is
	 * not 3 or 6, i.e. 'fff' or 'ffccff'.
	 */
	lengthText: "Color hex values must be either 3 or 6 characters.",
	
	//text to use if blank and allowBlank is false
	blankText: "Must have a hexidecimal value in the format ABCDEF.",
	
	/**
	 * @cfg {String} color
	 * A string hex value to be used as the default color.  Defaults
	 * to 'FFFFFF' (white).
	 */
	defaultColor: 'FFFFFF',
	
	maskRe: /[a-f0-9]/i,
	// These regexes limit input and validation to hex values
	regex: /[a-f0-9]/i,

	//private
	curColor: 'ffffff',
	
    // private
    validateValue : function(value){
		if(!this.showHexValue) {
			return true;
		}
		if(value.length<1) {
			this.el.setStyle({
				'background-color':'#' + this.defaultColor
			});
			if(!this.allowBlank) {
				this.markInvalid(String.format(this.blankText, value));
				return false
			}
			return true;
		}
		if(value.length!=3 && value.length!=6 ) {
			this.markInvalid(String.format(this.lengthText, value));
			return false;
		}
		this.setColor(value);
        return true;
    },

    // private
    validateBlur : function(){
        return !this.menu || !this.menu.isVisible();
    },
	
	// Manually apply the invalid line image since the background
	// was previously cleared so the color would show through.
	markInvalid : function( msg ) {
		Ext.ux.ColorField.superclass.markInvalid.call(this, msg);
		this.el.setStyle({
			'background-image': 'url(../theme/images/default/grid/invalid_line.gif)'
		});
	},

    /**
     * Returns the current color value of the color field
     * @return {String} value The hexidecimal color value
     */
    getValue : function(){
		return this.curValue || this.defaultValue || "FFFFFF";
    },

    /**
     * Sets the value of the color field.  Format as hex value 'FFFFFF'
     * without the '#'.
     * @param {String} hex The color value
     */
    setValue : function(hex){

		Ext.ux.ColorField.superclass.setValue.call(this, hex);
		this.setColor(hex);
    },
	
	/**
	 * Sets the current color and changes the background.
	 * Does *not* change the value of the field.
	 * @param {String} hex The color value.
	 */
	setColor : function(hex) {
		this.curColor = hex;
		
		this.el.setStyle( {
			'background-color': '#' + hex,
			'background-image': 'none'
		});
		if(!this.showHexValue) {
			this.el.setStyle({
				'text-indent': '-100px'
			});
			if(Ext.isIE) {
				this.el.setStyle({
					'margin-left': '100px'
				});
			}
		}
	},
	
	handleRender: function() {
		this.setDefaultColor();
	},
	
	setDefaultColor : function() {
		this.setValue(this.defaultColor);
	},

    // private
    menuListeners : {
        select: function(m, d){
            this.setValue(d);
        },
        show : function(){ // retain focus styling
            this.onFocus();
        },
        hide : function(){
            this.focus();
            var ml = this.menuListeners;
            this.menu.un("select", ml.select,  this);
            this.menu.un("show", ml.show,  this);
            this.menu.un("hide", ml.hide,  this);
        }
    },
	
	//private
	handleSelect : function(palette, selColor) {
    this.fireEvent("select",palette,selColor);
		this.setValue(selColor);
	},

    // private
    // Implements the default empty TriggerField.onTriggerClick function to display the ColorPicker
    onTriggerClick : function(){
        if(this.disabled){
            return;
        }
        if(this.menu == null){
            this.menu = new Ext.menu.ColorMenu();
			this.menu.palette.on('select', this.handleSelect, this );
        }
        this.menu.on(Ext.apply({}, this.menuListeners, {
            scope:this
        }));
        this.menu.show(this.el, "tl-bl?");
    }
});

Ext.reg("colorfield",Ext.ux.ColorField)


 /*JS File: ../js/drawing/tools.js*/ 


   Ax.ToolItem = Ext.extend(Ext.Component,{
  tool: "",
  imgclass: "",
  selected: false,
  onSelect: function(){},
  onUnselect: function(){},
  
  unselect: function(nofire){
	this.selected = false;
  this.el.dom.className = "toolboxItem"
	if(nofire!=true){
  this.onUnselect(this);
  }
  },
  select: function(nofire){
    this.el.dom.className = "toolboxItem"; //remove all classes except the standard one
    this.el.addClass("tbx_sel");
    this.selected = true
    if(nofire!=true){
			this.onSelect(this);
    }
  },
  initComponents: function(){
  Ax.ToolItem.superclass.initComponent.apply(this, arguments);
  },
  handleMouseEvents: function(event,del){
  
    //console.log(arguments)
    if(!this.el.hasClass("tbx_sel")){
    //If it is not selected
    this.el.dom.className = "toolboxItem"; //remove all classes except the standard one
    switch(event.type){
    case "mouseover":
    this.el.addClass("tbx_ovr")
    break;
    case "mouseout":
    this.el.addClass("tbx_idl")
    break;
    case "mousedown":
		//Ax.gs(9)
    this.onSelect(this);
    this.el.addClass("tbx_sel");
    this.selected = true
    break;
    }
    }else{
	//you shouldn't be able to not select any tool.
	
    //switch(event.type){
    //case "mousedown":
	//this.onUnselect(this);
    //this.el.dom.className = "toolboxItem";
    //this.selected = false;

    //}
    //If it is already selected
     }
  },
  onRender: function(ct){
  if(!this.template){
  this.template = new Ext.Template(
  //'<div id="{tool}" class="toolboxItem tbx_idl">',
  '<div class="toolboxButton {imgclass}"></div>');
  }
  if(!this.el){
  this.el = ct.createChild()
  }
  
  this.template.append(this.el,{tool: this.tool, imgclass: this.imgclass})
  
  
  this.el.dom.className = "toolboxItem tbx_idl"; //idle/toolbox
  
  
  this.el.on("mousedown",this.handleMouseEvents,this)
  this.el.on("mouseover",this.handleMouseEvents,this)
  this.el.on("mouseout",this.handleMouseEvents,this)
  
  if(this.qtip){
  //console.log(this.qtip)
  Ext.QuickTips.register({
    target: this.el.dom.firstChild,
    title: 'Draw Tools',
    text: this.qtip
    //dismissDelay: 20
  });
  }

  }
  
  })
  
  Ext.reg("tbxitem",Ax.ToolItem)


 /*JS File: ../js/drawing/toolbox.js*/ 


 Ax.toolConfig={
	"select":      ["tx_select","Select Shapes","Select"],
	"select+":     ["tx_selectadd","Add shapes to selection"],
	"rect":        ["tx_rectangle","Draw Rectangle","Rectangle"],
	"ellipse":     ["tx_circle","Draw Ellipse/Circle","Ellipse/Circle"],
	"line":        ["tx_line","Draw Line","Line"],
	"path":        ["tx_path","Draw freeform path","Freeform Path"],
	"polygon":     ["tx_polygon","Draw Polygon","Polygon"],
	"text":        ["tx_text","Draw text","Text"],
	"image":       ["tx_image", "Draw Image/Picture","Image"],

	//"shape":       ["tx_shape","Add a Shape from library","Library"],
	//"reset":       ["tx_reset","Reset/Clear/Empty Frame","Reset"],
	"delete":      ["tx_delete","Delete selected shape","Delete"]
}

Ax.ToolsPanel = Ext.extend(Ext.Panel,{

changeTool: function(tool){
Ax.setTool(tool.tool);
},

initComponent: function(){
var ia = []
for(var tool in Ax.toolConfig){


ia.push(new Ax.ToolItem({
tool:tool,
id: "tool_"+ tool,
toolConfig: Ax.toolConfig,
qtip: Ax.toolConfig[tool][1],
imgclass:Ax.toolConfig[tool][0], //ooh! gets the toolbox icons dir, and adds it to the stuff
onSelect: this.changeTool
}))
	
}
  
  
Ext.apply(this,{
layout: "table",
border: false,
layoutConfig: {
        // The total column count must be specified here
        columns: 2
    },
	items: ia
  })

   Ax.ToolsPanel.superclass.initComponent.apply(this, arguments);//i dont really know what that does
  }
  })
  
  Ext.reg("toolbox",Ax.ToolsPanel)
  
  
  
  

  
  



 /*JS File: ../js/drawing/colorpanel.js*/ 


 Ax.defaultcolor = {
  line: "000000",
  fill:"FFFFFF",
  fillopacity: 100,
  lineopacity: 100,
  width: 5, //okay, so width isn't really a color..
  grid: 1 //this isn't really a color either
}

Ax.Color = {
  update: function(){},
  line: Ax.defaultcolor.line,
  fill: Ax.defaultcolor.fill,
  fillopacity: Ax.defaultcolor.fillopacity,
  lineopacity: Ax.defaultcolor.lineopacity,
  width: Ax.defaultcolor.width,//okay, so width isn't really a color
  grid: Ax.defaultcolor.grid   //this is *my* _fav_ color.
}                           

Ax.setColors = function(c){
  //its probably bad to not use those pesky braces
  if (c.gd) { //grid
  	Ax.viewport.findById("fgd").setValue(c.gd)
  }
  if (c.lw) { //linewidth (stoke)
  	Ax.viewport.findById("flw").setValue(c.lw)
  }
  if (c.lc) {//linecolor (stroke)
  	Ax.viewport.findById("flc").setColor(c.lc)
  }
  if(c.fc){ //fill color
   Ax.viewport.findById("ffc").setColor(c.fc)
  }
  if (c.lo) {//lineopacity
  	Ax.viewport.findById("flo").setValue(c.lo)
  }
  if(c.fo){ //fill opacity
   Ax.viewport.findById("ffo").setValue(c.fo)
  }
}

Ax.ColorPanel = Ext.extend(Ext.Panel,{
  initComponent: function(){
    this.LWTip = new Ext.ux.SliderTip({
      getText: function(slider){
        return String.format('Line Width: {0}px', slider.getValue());
      }
    })
    this.LOTip = new Ext.ux.SliderTip({
      getText: function(slider){
        return String.format('Line Opacity: {0}%x', slider.getValue());
      }
    })
    this.FOTip = new Ext.ux.SliderTip({
      getText: function(slider){
        return String.format('Fill Opacity: {0}%x', slider.getValue());
      }
    })
    Ext.apply(this,{
    border: false,
    items: [
      {style: "font-size: xx-small; margin-left: 3px", html: "Line",border:false}, //for some reason cant do xtype:"label"
      {xtype: "slider", id: "flw",maxValue: 20,plugins: this.LWTip, value: Ax.Color.width, listeners: {
        "drag":function(slider,event){
          Ax.Color.width = slider.getValue(); //huh? width isn't a color? you're crazy
          Ax.Color.update("lw");
        }
      }},
      {xtype: "colorfield", id: "flc", width: 48, defaultColor:Ax.Color.line, listeners: {
        "select":function(palette,hex){
        Ax.Color.line = hex;
        Ax.Color.update("lc");
        }
      }},
      {xtype: "slider", id: "flo",maxValue: 100,plugins: this.LOTip, value: Ax.Color.lineopacity, listeners: {
        "drag":function(slider,event){
          Ax.Color.lineopacity = slider.getValue(); //huh? width isn't a color? you're crazy
          Ax.Color.update("lo");
        }
      }},
      {style: "font-size: xx-small; margin-left: 3px", html: "Fill",border:false},
      {xtype: "colorfield", id: "ffc",width: 48, defaultColor:Ax.Color.fill, listeners: {
        "select":function(palette,hex){
        Ax.Color.fill = hex;
        Ax.Color.update("fc");
        }
      }},
      {xtype: "slider", id: "ffo",maxValue: 100,plugins: this.FOTip, value: Ax.Color.fillopacity, listeners: {
        "drag":function(slider,event){
          Ax.Color.fillopacity = slider.getValue(); //huh? width isn't a color? you're crazy
          Ax.Color.update("fo");
        }
      }}
    ]
    })
    Ax.ColorPanel.superclass.initComponent.apply(this, arguments);
  }
})
Ext.reg("drawpanel",Ax.ColorPanel)




 /*JS File: ../js/drawing/vectoreditor/raphael.js*/ 
// bntr: include "VectorEditor/raphael-formatted.js"


 /*JS File: ../js/drawing/vectoreditor/editor.js*/ 


 
function VectorEditor(elem, width, height){
  if (typeof(Raphael) != "function") { //check for the renderer
      return alert("Error! Renderer is Missing!"); //if renderer isn't there, return false;
  }
  
  this.container = elem
  this.draw = Raphael(elem, width, height);
  
  this.draw.editor = this;
  
  this.onHitXY = [0,0]
  this.offsetXY = [0,0]
  this.tmpXY = [0,0]

  //cant think of any better way to do it
  this.prop = {
    "src": "http://upload.wikimedia.org/wikipedia/commons/a/a5/ComplexSinInATimeAxe.gif",
    "stroke-width": 1,
    "stroke": "#000000",
    "fill": "#ff0000",
    "stroke-opacity": 1,
    "fill-opacity": 1,
    "text": "Text"
  }
     
  this.mode = "select";
  this.selectbox = null;
  this.selected = []
  
  this.action = "";
  
  this.selectadd = false;
  
  this.shapes = []
  this.trackers = []
  
  this.listeners = {};
  
  
  var draw = this.draw;
  
  
  //THE FOLLOWING LINES ARE MOSTLY POINTLESS!
  
  function offset(){
    //technically, vX.pos works too and I should probably use whatever I built here, but I have jQuery instead.
    if(window.Ext)return Ext.get(elem).getXY();
    if(window.jQuery){
      var pos = jQuery(elem).offset();
      return [pos.left, pos.top];
    }
    if(window.vx){ //vx support
      var pos = vx.pos(elem);
      return [pos.l, pos.t]
    }
    return [0,0]
  }
  
  function bind(fn, scope){
    return function(){return fn.apply(scope, array(arguments))}
  }

  function array(a){
    for(var b=a.length,c=[];b--;)c.push(a[b]);
    return c;
  }
  if(window.Ext){
    Ext.get(elem).on("mousedown",function(event){
      event.preventDefault()
      
      if(event.button == 2){
        //this.lastmode = this.mode;
        this.setMode("select") //tempselect
      }
      if(event.button == 1){
        return;
      }
      this.onMouseDown(event.getPageX() - offset()[0], event.getPageY() - offset()[1], event.getTarget())
      return false;
    }, this);
    Ext.get(elem).on("mousemove",function(event){
      event.preventDefault()
      this.onMouseMove(event.getPageX()  - offset()[0], event.getPageY()- offset()[1], event.getTarget())
      return false;
    }, this)
    Ext.get(elem).on("mouseup",function(event){
      event.preventDefault()
      this.onMouseUp(event.getPageX() - offset()[0], event.getPageY() - offset()[1], event.getTarget())
      return false;
    }, this)
    Ext.get(elem).on("dblclick",function(event){
      event.preventDefault()
      this.onDblClick(event.getPageX() - offset()[0], event.getPageY()- offset()[1], event.getTarget())
      return false;
    }, this)
  }else if(window.jQuery){
    $(elem).mousedown(bind(function(event){
      event.preventDefault()
      
      if(event.button == 2){
        //this.lastmode = this.mode;
        this.setMode("select") //tempselect
      }
      this.onMouseDown(event.clientX - offset()[0], event.clientY - offset()[1], event.target)
    }, this));
    $(elem).mousemove(bind(function(event){
      event.preventDefault()
      this.onMouseMove(event.clientX - offset()[0], event.clientY - offset()[1], event.target)
    }, this));
    $(elem).mouseup(bind(function(event){
      event.preventDefault()
      this.onMouseUp(event.clientX - offset()[0], event.clientY - offset()[1], event.target)
    }, this));
    $(elem).dblclick(bind(function(event){
      event.preventDefault()
      this.onDblClick(event.clientX - offset()[0], event.clientY - offset()[1], event.target)
    }, this));
  }
}

VectorEditor.prototype.setMode = function(mode){
  this.fire("setmode",mode)
  if(mode == "select+"){
    this.mode = "select";
    this.selectadd = true;
    this.unselect()
  }else if(mode == "select"){
    this.mode = mode;
    this.unselect()
    this.selectadd = false;
  }else if(mode == "delete"){
    this.deleteSelection();
    this.mode = mode;
  }else{
    this.unselect()
    this.mode = mode;
  }
}

VectorEditor.prototype.on = function(event, callback){
  if(!this.listeners[event]){
    this.listeners[event] = []
  }
  
  if(this.in_array(callback,this.listeners[event])  ==  -1){
    this.listeners[event].push(callback);
  }
}


VectorEditor.prototype.returnRotatedPoint = function(x,y,cx,cy,a){
    // http://mathforum.org/library/drmath/view/63184.html
    
    // radius using distance formula
    var r = Math.sqrt((x-cx)*(x-cx) + (y-cy)*(y-cy));
    // initial angle in relation to center
    var iA = Math.atan2((y-cy),(x-cx)) * (180/Math.PI);

    var nx = r * Math.cos((a + iA)/(180/Math.PI));
    var ny = r * Math.sin((a + iA)/(180/Math.PI));

    return [cx+nx,cy+ny];
}

VectorEditor.prototype.fire = function(event){
  if(this.listeners[event]){
    for(var i = 0; i < this.listeners[event].length; i++){
      if(this.listeners[event][i].apply(this, arguments)===false){
        return false;
      }
    }
  }
}

VectorEditor.prototype.un = function(event, callback){
  if(!this.listeners[event])return;
  var index = 0;
  while((index = this.in_array(callback,this.listeners[event])) != -1){
    this.listeners[event].splice(index,1);
  }
}

//from the vXJS JS Library
VectorEditor.prototype.in_array = function(v,a){
  for(var i=a.length;i--&&a[i]!=v;);
  return i
}

//from vX JS, is it at all strange that I'm using my own work?
VectorEditor.prototype.array_remove = function(e, o){
  var x=this.in_array(e,o);
  x!=-1?o.splice(x,1):0
}


VectorEditor.prototype.is_selected = function(shape){
  return this.in_array(shape, this.selected) != -1;
}

VectorEditor.prototype.set_attr = function(){
  for(var i = 0; i < this.selected.length; i++){
    this.selected[i].attr.apply(this.selected[i], arguments)
  }
}

VectorEditor.prototype.set = function(name, value){
  this.prop[name] = value;
  this.set_attr(name, value);
}

VectorEditor.prototype.onMouseDown = function(x, y, target){
  this.fire("mousedown")
  this.tmpXY = this.onHitXY = [x,y]
  
  if(this.mode == "select" && !this.selectbox){

    var shape_object = null
    if(target.shape_object){
      shape_object = target.shape_object
    }else if(target.parentNode.shape_object){
      shape_object = target.parentNode.shape_object
    }else if(!target.is_tracker){
      if(!this.selectadd) this.unselect();
      this.selectbox = this.draw.rect(x, y, 0, 0)
        .attr({"fill-opacity": 0.15, 
              "stroke-opacity": 0.5, 
              "fill": "#007fff", //mah fav kolur!
              "stroke": "#007fff"});
      return; 
    }else{
      return; //die trackers die!
    }
    
    
    if(this.selectadd){
      this.selectAdd(shape_object);
      this.action = "move";
    }else if(!this.is_selected(shape_object)){
      this.select(shape_object);
      this.action = "move";
    }else{
      this.action = "move";
    }
    this.offsetXY = [shape_object.attr("x") - x,shape_object.attr("y") - y]
    
  }else if(this.mode == "delete" && !this.selectbox){
    var shape_object = null
    if(target.shape_object){
      shape_object = target.shape_object
    }else if(target.parentNode.shape_object){
      shape_object = target.parentNode.shape_object
    }else if(!target.is_tracker){
      this.selectbox = this.draw.rect(x, y, 0, 0)
        .attr({"fill-opacity": 0.15, 
              "stroke-opacity": 0.5, 
              "fill": "#ff0000", //oh noes! its red and gonna asplodes!
              "stroke": "#ff0000"});
      return;
    }else{
      return; //likely tracker
    }
    this.deleteShape(shape_object)
    this.offsetXY = [shape_object.attr("x") - x,shape_object.attr("y") - y]
  }else if(this.selected.length == 0){
    var shape = null;
    if(this.mode == "rect"){
      shape = this.draw.rect(x, y, 0, 0);
    }else if(this.mode == "ellipse"){
      shape = this.draw.ellipse(x, y, 0, 0);
    }else if(this.mode == "path"){
      shape = this.draw.path("M{0},{1}",x,y)
    }else if(this.mode == "line"){
      shape = this.draw.path("M{0},{1}",x,y)
      shape.subtype = "line"
    }else if(this.mode == "polygon"){
      shape = this.draw.path("M{0},{1}",x,y)
      shape.polypoints = [[x,y]]
      shape.subtype = "polygon"
    }else if(this.mode == "image"){
      shape = this.draw.image(this.prop.src, x, y, 0, 0);
      
      //WARNING NEXT IS A HACK!!!!!!
      //shape.attr("src",this.prop.src); //raphael won't return src correctly otherwise
    }else if(this.mode == "text"){
      shape = this.draw.text(x, y, this.prop['text']).attr('font-size',0)
      shape.text = this.prop['text'];
      //WARNING NEXT IS A HACK!!!!!!
      //shape.attr("text",this.prop.text); //raphael won't return src correctly otherwise
    }
    if(shape){
      //shape.id = this.generateUUID();
      shape.id = shape.type + shape.id; // bntr: readable better than random
      shape.attr({
          "fill": this.prop.fill, 
          "stroke": this.prop.stroke,
          "stroke-width": this.prop["stroke-width"],
          "fill-opacity": this.prop['fill-opacity'],
          "stroke-opacity": this.prop["stroke-opacity"]
      })
      this.addShape(shape)
    }
  }else{
    
  }
  return false;
}

VectorEditor.prototype.onMouseMove = function(x, y, target){


  this.fire("mousemove")
  if(this.mode == "select" || this.mode == "delete"){
    if(this.selectbox){
      this.resize(this.selectbox, x - this.onHitXY[0], y - this.onHitXY[1], this.onHitXY[0], this.onHitXY[1])
    }else if(this.mode == "select"){
      if(this.action == "move"){
        for(var i = 0; i < this.selected.length; i++){
          this.move(this.selected[i], x - this.tmpXY[0], y - this.tmpXY[1])
        }
        //this.moveTracker(x - this.tmpXY[0], y - this.tmpXY[1])
        this.updateTracker();
        this.tmpXY = [x, y];
        
      }else if(this.action == "rotate"){
        //no multi-rotate
        var box = this.selected[0].getBBox()
        var rad = Math.atan2(y - (box.y + box.height/2), x - (box.x + box.width/2))
        var deg = ((((rad * (180/Math.PI))+90) % 360)+360) % 360;
        this.selected[0].rotate(deg, true); //absolute!
        //this.rotateTracker(deg, (box.x + box.width/2), (box.y + box.height/2))
        this.updateTracker();
      }else if(this.action.substr(0,4) == "path"){
        var num = parseInt(this.action.substr(4))
        var pathsplit = Raphael.parsePathString(this.selected[0].attr("path"))
        if(pathsplit[num]){
          pathsplit[num][1] = x
          pathsplit[num][2] = y
          this.selected[0].attr("path", pathsplit)
          this.updateTracker()
        }
      }else if(this.action == "resize"){
        if(!this.onGrabXY){ //technically a misnomer
          if(this.selected[0].type == "ellipse"){
          this.onGrabXY = [
            this.selected[0].attr("cx"),
            this.selected[0].attr("cy")
          ]
          }else if(this.selected[0].type == "path"){
            this.onGrabXY = [
              this.selected[0].getBBox().x,
              this.selected[0].getBBox().y,
              this.selected[0].getBBox().width,
              this.selected[0].getBBox().height
            ]
          }else{
            this.onGrabXY = [
              this.selected[0].attr("x"),
              this.selected[0].attr("y")
            ]
          }
          //this.onGrabBox = this.selected[0].getBBox()
        }
        var box = this.selected[0].getBBox()
        var nxy = this.returnRotatedPoint(x, y, box.x + box.width/2, box.y + box.height/2, -this.selected[0].attr("rotation"))
        x = nxy[0] - 5
        y = nxy[1] - 5
        if(this.selected[0].type == "rect"){
          this.resize(this.selected[0], x - this.onGrabXY[0], y - this.onGrabXY[1], this.onGrabXY[0], this.onGrabXY[1])
        }else if(this.selected[0].type == "image"){
          this.resize(this.selected[0], x - this.onGrabXY[0], y - this.onGrabXY[1], this.onGrabXY[0], this.onGrabXY[1])
        }else if(this.selected[0].type == "ellipse"){
          this.resize(this.selected[0], x - this.onGrabXY[0], y - this.onGrabXY[1], this.onGrabXY[0], this.onGrabXY[1])
        }else if(this.selected[0].type == "text"){
          this.resize(this.selected[0], x - this.onGrabXY[0], y - this.onGrabXY[1], this.onGrabXY[0], this.onGrabXY[1])
        }else if(this.selected[0].type == "path"){
          this.selected[0].scale((x - this.onGrabXY[0])/this.onGrabXY[2], (y - this.onGrabXY[1])/this.onGrabXY[3], this.onGrabXY[0], this.onGrabXY[1])
        }
        this.newTracker(this.selected[0])
      }
    }
  }else if(this.selected.length == 1){
    if(this.mode == "rect"){
      this.resize(this.selected[0], x - this.onHitXY[0], y - this.onHitXY[1], this.onHitXY[0], this.onHitXY[1])
    }else if(this.mode == "image"){
      this.resize(this.selected[0], x - this.onHitXY[0], y - this.onHitXY[1], this.onHitXY[0], this.onHitXY[1])
    }else if(this.mode == "ellipse"){
      this.resize(this.selected[0], x - this.onHitXY[0], y - this.onHitXY[1], this.onHitXY[0], this.onHitXY[1])
    }else if(this.mode == "text"){
      this.resize(this.selected[0], x - this.onHitXY[0], y - this.onHitXY[1], this.onHitXY[0], this.onHitXY[1])
    }else if(this.mode == "path"){
      //this.selected[0].lineTo(x, y);
      this.selected[0].attr("path", this.selected[0].attrs.path + 'L'+x+' '+y)
    }else if(this.mode == "polygon" || this.mode == "line"){
      //this.selected[0].path[this.selected[0].path.length - 1].arg[0] = x
      //this.selected[0].path[this.selected[0].path.length - 1].arg[1] = y
      //this.selected[0].redraw();
      //var pathsplit = this.selected[0].attr("path").split(" ");
      
      //theres a few freaky bugs that happen due to this new IE capable way that is probably better
    
      var pathsplit = Raphael.parsePathString(this.selected[0].attr("path"))
      if(pathsplit.length > 1){
        //var hack = pathsplit.reverse().slice(3).reverse().join(" ")+' ';
        
        //console.log(pathsplit)
        if(this.mode == "line"){
          //safety measure, the next should work, but in practice, no
          pathsplit.splice(1)
        }else{
          var last = pathsplit[pathsplit.length -1];
          //console.log(this.selected[0].polypoints.length, pathsplit.length)
          if(this.selected[0].polypoints.length < pathsplit.length){
          //if(Math.floor(last[1]) == this.lastpointsX && Math.floor(last[2]) == this.lastpointsY){
            pathsplit.splice(pathsplit.length - 1, 1);
            }
          //}else{
          //  console.log(last[1], last[2], this.lastpointsX, this.lastpointsY)
          //}
        }
        //this.lastpointsX = x; //TO FIX A NASTY UGLY BUG
        //this.lastpointsY = y; //SERIOUSLY
        
        this.selected[0].attr("path", pathsplit.toString() + 'L'+x+' '+y)
        
      }else{
        //console.debug(pathsplit)
        //normally when this executes there's somethign strange that happened
        this.selected[0].attr("path", this.selected[0].attrs.path + 'L'+x+' '+y)
      }
      //this.selected[0].lineTo(x, y)
    }
  }
  
  return false;
}


VectorEditor.prototype.getMarkup = function(){
    return this.draw.canvas.parentNode.innerHTML;
}


VectorEditor.prototype.onDblClick = function(x, y, target){
  this.fire("dblclick")
  if(this.selected.length == 1){
    if(this.selected[0].getBBox().height == 0 && this.selected[0].getBBox().width == 0){
      this.deleteShape(this.selected[0])
    }
    if(this.mode == "polygon"){
      //this.selected[0].andClose()
      this.unselect()
    }
  }
  return false;
}



VectorEditor.prototype.onMouseUp = function(x, y, target){
  this.fire("mouseup")
  this.onGrabXY = null;
  
  if(this.mode == "select" || this.mode == "delete"){
    if(this.selectbox){
      var sbox = this.selectbox.getBBox()
      var new_selected = [];
      for(var i = 0; i < this.shapes.length; i++){
        if(this.rectsIntersect(this.shapes[i].getBBox(), sbox)){
          new_selected.push(this.shapes[i])
        }
      }
      
      if(new_selected.length == 0 || this.selectadd == false){
        this.unselect()
      }
      
      if(new_selected.length == 1 && this.selectadd == false){
        this.select(new_selected[0])
      }else{
        for(var i = 0; i < new_selected.length; i++){
          this.selectAdd(new_selected[i])
        }
      }
      if(this.selectbox.node.parentNode){
        this.selectbox.remove()
      }
      this.selectbox = null;
      
      if(this.mode == "delete"){
        this.deleteSelection();
      }
      
    }else{
      this.action = "";
    }
  }else if(this.selected.length == 1){
    if(this.selected[0].getBBox().height == 0 && this.selected[0].getBBox().width == 0){
      if(this.selected[0].subtype != "polygon"){
        this.deleteShape(this.selected[0])
      }
    }
    if(this.mode == "rect"){
      this.unselect()
    }else if(this.mode == "ellipse"){
      this.unselect()
    }else if(this.mode == "path"){
      this.unselect()
    }else if(this.mode == "line"){
      this.unselect()
    }else if(this.mode == "image"){
      this.unselect()
    }else if(this.mode == "text"){
      this.unselect()
    }else if(this.mode == "polygon"){
        //this.selected[0].lineTo(x, y)
      this.selected[0].attr("path", this.selected[0].attrs.path + 'L'+x+' '+y)
      if(!this.selected[0].polypoints) this.selected[0].polypoints = [];
      this.selected[0].polypoints.push([x,y])  
      
    }
  }
  if(this.lastmode){
    this.setMode(this.lastmode);
    //this.mode = this.lastmode //not selectmode becasue that unselects
    delete this.lastmode;
  }
  return false;
}





 /*JS File: ../js/drawing/vectoreditor/tracker.js*/ 


 VectorEditor.prototype.unselect = function(shape){

  if(!shape){
    while(this.selected[0]){
      this.unselect(this.selected[0])
    }
    if(shape !== false){
      this.fire("unselected")
    }
  }else{
    this.fire("unselect", shape);
    this.array_remove(shape, this.selected);
    for(var i = 0; i < this.trackers.length; i++){
      if(this.trackers[i].shape == shape){
        this.removeTracker(this.trackers[i]);
      }
    }
  }
}


VectorEditor.prototype.selectAdd = function(shape){
  if(this.is_selected(shape) == false){
    if(this.fire("selectadd",shape)===false)return;
    
    this.selected.push(shape)
    this.showGroupTracker(shape);
  }
}

VectorEditor.prototype.selectAll = function(){
  this.unselect()
  for(var i = 0; i < this.shapes.length; i++){
    this.selectAdd(this.shapes[i])
    
  }
}

VectorEditor.prototype.selectToggle = function(shape){
  if(this.is_selected(shape) == false){
    this.selectAdd(shape)
  }else{
    this.unselect(shape)
  }
}

VectorEditor.prototype.select = function(shape){
  if(this.fire("select",shape)===false)return;
  this.unselect(false)
  this.selected = [shape]
  this.showTracker(shape)
}



VectorEditor.prototype.removeTracker = function(tracker){
  if(!tracker){
    while(this.trackers.length > 0){
      this.removeTracker(this.trackers[0]);
    }
  }else{
    tracker.remove();
    
    for(var i = 0; i < this.trackers.length; i++){
      if(this.trackers[i] == tracker){
        this.trackers.splice(i, 1)
      }
    }
  }
}


VectorEditor.prototype.updateTracker = function(tracker){
  if(!tracker){
    for(var i = 0; i < this.trackers.length; i++){
      this.updateTracker(this.trackers[i])
    }
  }else{
    var shape = tracker.shape;
    var box = shape.getBBox();
    //this is somewhat hackish, if someone finds a better way to do it...
    if(shape.type == "path" && this.action.substr(0,4) == "path"){
      var pathsplit = Raphael.parsePathString(shape.attr("path"))
      if(pathsplit.length == 2){
        tracker[0].attr({cx: box.x + box.width/2, cy: box.y + box.height/2})
        tracker[1].attr({x: pathsplit[0][1]-2, y: pathsplit[0][2]-2})
        tracker[2].attr({x: pathsplit[1][1]-2, y: pathsplit[1][2]-2})
      }
      return;
    }

    //i wish my code could be as dated as possible by referencing pieces of culture
    //though I *hope* nobody needs to use svg/vml whatever in the near future
    //there coudl be a lot of better things
    //and svg-edit is a better project
    //so if the future even uses raphael, then microsoft really sucks
    //it truly is "more evil than satan himself" which is itself dated even for the time of writing
    //and am I ever gonna read this? If it's someone that's not me that's reading this
    //please tell me (if year > 2010 or otherwise)
    tracker.translate(box.x - tracker.lastx, box.y - tracker.lasty)
    
    //now here for the magic
    if(shape._ && shape._.rt){
      tracker.rotate(shape._.rt.deg, (box.x + box.width/2), (box.y + box.height/2))
    }
    
    tracker.lastx = box.x//y = boxxy trollin!
    tracker.lasty = box.y
  }
}
VectorEditor.prototype.trackerBox = function(x, y, action){
  var w = 4
  var shape = this.draw.rect(x - w, y - w, 2*w, 2*w).attr({
    "stroke-width": 1,
    "stroke": "green",
    "fill": "white"
  //THE FOLLOWING LINES HAVE BEEN COMMENTED DUE TO A HORRIBLE BUG IN RAPHAEL
  }).mouseover(function(){
    this.attr("fill", "red")
    try{ //easy way out! try catch!
      if(this.paper.editor.trackers[0][0].attr("rotation").split(" ")[0] == "0" && this.paper.editor.action != "resize"){ //ugh
        this.paper.editor.tooltip("Click and drag to resize shape",
       {x: this.attr("x")+10, y: this.attr("y")+5});
      }else{
        this.paper.editor.hideTooltip()
      }
    }catch(err){}
     
  }).mouseout(function(){
    this.attr("fill", "white")
    this.paper.editor.hideTooltip()
    
  }).mousedown(function(event){
    //console.log(event)
    this.paper.editor.action = action;
  })
  shape.node.is_tracker = true;
  return shape;
}

VectorEditor.prototype.trackerCircle = function(x, y){
  var w = 5
  var shape = this.draw.ellipse(x, y, w, w).attr({
    "stroke-width": 1,
    "stroke": "green",
    "fill": "white"
  //THE FOLLOWING LINES HAVE BEEN COMMENTED DUE TO A HORRIBLE BUG IN RAPHAEL
  }).mouseover(function(){
    this.attr("fill", "red")
    try{ //easy way out! try catch!
      if(this.paper.editor.trackers[0][0].attr("rotation").split(" ")[0] == "0"){ //ewwie!
      this.paper.editor.tooltip("Drag to rotate shape or double click to reset.",
       {x: this.attr("cx")+5, y: this.attr("cy")});
      }
    }catch(err){}
  }).mouseout(function(){
    this.attr("fill", "white")
    this.paper.editor.hideTooltip()
  }).mousedown(function(){
    this.paper.editor.action = "rotate";
  }).dblclick(function(){
    this.paper.editor.trackers[0].shape.rotate(0, true); //absolute!
    this.paper.editor.updateTracker();
  });
  shape.node.is_tracker = true;
  return shape;
}

VectorEditor.prototype.hideTooltip = function(){
  this.tt.hide();
}

VectorEditor.prototype.tooltip = function(t,bbox){
  if(!this.tt){
    var set = this.draw.set();
    set.push(this.draw.text(0,0,"x"))
    set.push(this.draw.rect(0,0,1,1))
    this.tt = set;
  }
  var set = this.tt;
  
  set.show();
  set.toFront();
  var text = set[0];
  var rect = set[1];
  text.attr("text", t);
  text.attr("x", bbox.x);
  text.attr("y", bbox.y);
  var txb = text.getBBox() //i wish i knew a better way to align it like that
  text.attr("x", bbox.x + txb.width/2 + 8)
  txb = text.getBBox()
  
  rect.attr({
      x: txb.x-5,
      y: txb.y,
      width: txb.width+10,
      height: txb.height,
      r: 3
    })
  rect.attr("fill","#7cb6ef") //it's the first 6 letters of the hex SHA1 hash of "false"
    .insertBefore(text);
  
  return set;
}

VectorEditor.prototype.markTracker = function(shape){
  shape.node.is_tracker = true;
  return shape;
}


VectorEditor.prototype.newTracker = function(shape){
  for(var i = 0; i < this.trackers.length; i++){
    if(this.trackers[i].shape == shape){
      this.removeTracker(this.trackers[i]);
    }
  }
  this.showTracker(shape)
}

VectorEditor.prototype.showTracker = function(shape){
  var rot_offset = -14;
  var box = shape.getBBox();
  var tracker = this.draw.set();
  tracker.shape = shape;
  
  //define the origin to transform to
  tracker.lastx = 0 //if zero then easier
  tracker.lasty = 0 //if zero then easier
  
  tracker.push(this.markTracker(this.draw.ellipse(box.width/2, box.height/2, 7, 7).attr({
        "stroke": "gray",
        "stroke-opacity": 0.5,
        "fill": "gray",
        "fill-opacity": 0.15
      })).mousedown(function(){
        this.paper.editor.action = "move"
      }));
  
  //draw everything relative to origin (0,0) because it gets transformed later
  if(shape.subtype == "line"){
    var line = Raphael.parsePathString(shape.attr('path'));
    
    tracker.push(this.trackerBox(line[0][1]-box.x,line[0][2]-box.y,"path0"))
    tracker.push(this.trackerBox(line[1][1]-box.x,line[1][2]-box.y,"path1"))
    this.trackers.push(tracker)
  }else if(shape.type == "rect" || shape.type == "image"){
    tracker.push(this.draw.rect(-6, -6, box.width + 11, box.height + 11).attr({"opacity":0.3}))
    //tracker.push(this.trackerBox(-10, -10))
    //tracker.push(this.trackerBox(box.width + 10, -10))
    //tracker.push(this.trackerBox(box.width + 10, box.height + 10))
    //tracker.push(this.trackerBox(-10, box.height + 10))
    tracker.push(this.trackerCircle(box.width/2, rot_offset))
    tracker.push(this.trackerBox(box.width+5,box.height+5,"resize"))
    this.trackers.push(tracker)
  }else if(shape.type == "ellipse"){
    //tracker.push(this.trackerBox(box.x, box.y))
    //tracker.push(this.trackerBox(box.width, box.y))
    //tracker.push(this.trackerBox(box.width, box.height))
    //tracker.push(this.trackerBox(box.x, box.height))
    tracker.push(this.trackerCircle(box.width/2, rot_offset))
    tracker.push(this.trackerBox(box.width+5,box.height+5,"resize"))
    this.trackers.push(tracker)
  }else if(shape.type == "text"){
    tracker.push(this.draw.rect(-6, -6, box.width + 11, box.height + 11).attr({"opacity":0.3}))
    tracker.push(this.trackerCircle(box.width/2, rot_offset))
    tracker.push(this.trackerBox(box.width+5,box.height+5,"resize"))
    this.trackers.push(tracker)
  }else if(shape.type == "path" && shape.subtype != "line"){
    tracker.push(this.draw.rect(-6, -6, box.width + 11, box.height + 11).attr({"opacity":0.3}))
    tracker.push(this.trackerBox(box.width+5,box.height+5,"resize"))
    tracker.push(this.trackerCircle(box.width/2, rot_offset))
    this.trackers.push(tracker)
  }else{
    tracker.push(this.draw.rect(-6, -6, box.width + 11, box.height + 11).attr({"opacity":0.3}))
    tracker.push(this.trackerCircle(box.width/2, rot_offset))
    this.trackers.push(tracker)
  }
  this.updateTracker(tracker)
}

VectorEditor.prototype.showGroupTracker = function(shape){
  var tracker = this.draw.set();
  var box = shape.getBBox();
  
  tracker.push(this.markTracker(this.draw.ellipse(box.width/2, box.height/2, 7, 7).attr({
      "stroke": "gray",
      "stroke-opacity": 0.5,
      "fill": "gray",
      "fill-opacity": 0.15
    })).mousedown(function(){
      this.paper.editor.action = "move"
    }));
  
  tracker.push(this.draw.rect(-6, -6, box.width + 11, box.height + 11).attr({
    "stroke-dasharray": "-",
    "stroke": "blue"
  }))
  tracker.shape = shape;
  //define the origin to transform to
  tracker.lastx = 0 //if zero then easier
  tracker.lasty = 0 //if zero then easier
  this.trackers.push(tracker)
  
  this.updateTracker(tracker)
}




 /*JS File: ../js/drawing/vectoreditor/shape.js*/ 


 VectorEditor.prototype.deleteSelection = function(){
  while(this.selected.length > 0){
    this.deleteShape(this.selected[0])
  }
}

VectorEditor.prototype.deleteShape = function(shape,nofire){
  if(!nofire){if(this.fire("delete",shape)===false)return;}

  if(shape && shape.node && shape.node.parentNode){
    shape.remove()
  }
  for(var i = 0; i < this.trackers.length; i++){
    if(this.trackers[i].shape == shape){
      this.removeTracker(this.trackers[i]);
    }
  }
  for(var i = 0; i < this.shapes.length; i++){
    if(this.shapes[i] == shape){
      this.shapes.splice(i, 1)
    }
  }
  for(var i = 0; i < this.selected.length; i++){
    if(this.selected[i] == shape){
      this.selected.splice(i, 1)
    }
  }
  //should remove references, but whatever
}

VectorEditor.prototype.deleteAll = function(){
  this.fire("clear2")
  this.draw.clear()
  this.shapes = []
  this.trackers = []
}

VectorEditor.prototype.clearShapes = function(){
  this.fire("clear")
  while(this.shapes.length > 0){
    this.deleteShape(this.shapes[0],true) //nofire
  }
}

VectorEditor.prototype.generateUUID = function(){
  var uuid = "", d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for(var i = 0; i < 4/*16*/; i++){
    uuid += d.charAt(Math.floor(Math.random()*(i?d.length:(d.length-10))));
  }
  return uuid;
}

VectorEditor.prototype.getShapeById = function(v){
  for(var i=this.shapes.length;i--&&this.shapes[i].id!=v;);
  return this.shapes[i]
}

VectorEditor.prototype.addShape = function(shape,no_select, no_fire){
  if(!no_fire)this.fire("addshape",shape,no_select);
  shape.node.shape_object = shape
  if(!no_select){
    this.selected = [shape]
  }
  this.shapes.push(shape)
  if(!no_fire)this.fire("addedshape",shape,no_select);
}

VectorEditor.prototype.rectsIntersect = function(r1, r2) {
  return r2.x < (r1.x+r1.width) && 
          (r2.x+r2.width) > r1.x &&
          r2.y < (r1.y+r1.height) &&
          (r2.y+r2.height) > r1.y;
}

VectorEditor.prototype.drawGrid = function(){
  this.draw.drawGrid(0, 0, 480, 272, 10, 10, "blue").toBack()
}

VectorEditor.prototype.move = function(shape, x, y){
  //HACKITY HACK HACK
  //var rot = null;
  //if(shape._ && shape._.rt){
  //  rot = shape._.rt.deg
  //}
  
  //<here's the part that isn't a hack>
  shape.translate(x,y)
  //</end non-hack>
  
  //HACKITY HACK HACK
  //if(rot){
  //  shape.rotate(rot,true)//absolutelyness
  //}
  //if(shape._ && shape._.rt){
  //  shape.rotate(shape._.rt.deg, true)
  //}
}


VectorEditor.prototype.scale = function(shape, corner, x, y){
  var xp = 0, yp = 0
  var box = shape.getBBox()
  switch(corner){
    case "tr":
      xp = box.x
      yp = box.y + box.height
      break;
    case "bl":
      xp = box.x + box.width
      yp = box.y
      break;
    case "tl":
      xp = box.x + box.width;
      yp = box.y + box.height;
    break;
    case "br":
      xp = box.x
      yp = box.y
    break;
  }
  shape.scale(x, y, xp, yp)
}

VectorEditor.prototype.fixText = function(str){
  return window.Ax?Ax.textfix(str):str;
}

VectorEditor.prototype.resize = function(object, width, height, x, y){
  if(object.type == "rect" || object.type == "image"){
    if(width > 0){
      object.attr("width", width)
    }else{
      object.attr("x", (x?x:object.attr("x"))+width)
      object.attr("width", Math.abs(width)) 
    }
    if(height > 0){
      object.attr("height", height)
    }else{
      object.attr("y", (y?y:object.attr("y"))+height)
      object.attr("height", Math.abs(height)) 
    }
  }else if(object.type == "ellipse"){
    if(width > 0){
      object.attr("rx", width)
    }else{
      object.attr("x", (x?x:object.attr("x"))+width)
      object.attr("rx", Math.abs(width)) 
    }
    if(height > 0){
      object.attr("ry", height)
    }else{
      object.attr("y", (y?y:object.attr("y"))+height)
      object.attr("ry", Math.abs(height)) 
    }
  }else if(object.type == "text"){
    object.attr("font-size", Math.abs(width))
    //object.node.style.fontSize = null;
  }
}




 /*JS File: ../js/drawing/wrapper_core.js*/ 


 /**
 * @author antimatter15
 */

Ax.use_compat = true;

Ax.noloadids = [];

Ax.backcompat = {
    'fill': 'fillColor',
    'stroke': 'lineColor',
    //fill opac and line opac aren't actually supported in the old one so i'll save the tweening of it
    'stroke-width': 'lineWidth',
    'x': 'left',
    'y': 'top'
  }

Ax.loadShapes = function(shapes, noattachlistener, instance){ //instance; probably need a better name for this. but its the richdraw/onlypaths/viewer/etc reference. 
  
  if (typeof shapes == "string") { //try un-scrabling this!
        shapes = Ext.util.JSON.decode(shapes);
  }else if(!shapes){
		return;
	}
	for (var i = 0; i < shapes.length; i++) {
		Ax.loadShape(shapes[i], noattachlistener, instance);
	}
}

Ax.loadShape = function(shape, noattachlistener, instance){
    instance = instance?instance:Ax.canvas
    
    if(Ax.noloadids.length > 0 && shape.id){
      if(Ax.noloadids.indexOf(shape.id) != -1){
        return;
      }
    }
    
    //backwards compatability
    for(var now in Ax.backcompat){ //loop compat list
      //info[backcompat[now]] = info[now];
      if(!shape[now] && shape[Ax.backcompat[now]]){ //if new one no existy, but old one existy
        shape[now] = shape[Ax.backcompat[now]]; //schwappy!
      }
    }
    
	  var newshape = null, draw = instance.draw;
	  if(shape.type == "rect"){
	    newshape = draw.rect(0, 0,0, 0)
	  }else if(shape.type == "path"){
	    newshape = draw.path("")
      
	  }else if(shape.type == "image"){
      newshape = draw.image(shape.src, 0, 0, 0, 0)
    }else if(shape.type == "ellipse"){
      newshape = draw.ellipse(0, 0, 0, 0)
    }else if(shape.type == "text"){
      if(Ax.textfix){
        shape.text = Ax.textfix(shape.text)
      }
      newshape = draw.text(0, 0, (shape.text))
      newshape.text = shape.text;
    }
    

    
    //oopsy! rotations not supported!

	  if(newshape){
	    newshape.attr(shape)
	    newshape.id = shape.id
	    newshape.subtype = shape.subtype
	    
      if (!noattachlistener) {
        instance.addShape(newshape,true,true)
      }else{
        if(!instance.no_listener_shapes){
          instance.no_listener_shapes = []
        }
        instance.no_listener_shapes.push(newshape)
      }
	  }
	  return newshape
}

Ax.dumpshape = function(shape){
    var info = {
      type: shape.type,
      id: shape.id,
      subtype: shape.subtype
    }
    var attr = "cx,cy,fill,fill-opacity,font-size,font-weight,gradient,height,opacity,path,r,rx,ry,src,stroke,stroke-dasharray,stroke-opacity,stroke-width,width,x,y,rotation".split(",")
    for(var i = 0; i < attr.length; i++){
      var tmp = shape.attr(attr[i]);
      if(tmp !== null && tmp !== false && tmp !== undefined){
        if(attr[i] == "path"){
          info[attr[i]] = Ax.parsePath(tmp)
        }else{
          info[attr[i]] = tmp
        }
      }
    }
    

    //forwards compatability (or is it backwards?)
    
    /* SORRY! Google doesn't want me to waste ANY bytes
     
    if(Ax.use_compat == true){
      for(var now in Ax.backcompat){
        
        info[Ax.backcompat[now]] = info[now];
      }
    }
    
    */
    
    if(shape.text){
      info.text = shape.text; //hAAK
      
    }
    //HACKITY HACK HACK!!!!
    //if(shape && shape._ && shape._.rt && shape._.rt.deg){
    //  info['rotation'] = shape._.rt.deg;
    //}else{
    //  info.rotation = 0;
    //}
    
    return info
}

Ax.dumpshapes_core = function(){
    var rawshapes = Ax.canvas.shapes;
    var newshapes = [];
    for (var i = 0; i < rawshapes.length; i++) {
      newshapes.push(Ax.dumpshape(rawshapes[i]));
    }
	return newshapes
}

Ax.dumpshapes = function(format){
    if (format == "json") {
        return Ext.util.JSON.encode(Ax.dumpshapes_core())
    }
    else {
        return Ax.dumpshapes_core();
    }
}



 /*JS File: ../js/drawing/op_wrapper.js*/ 


 /**
* Heh. This file provides wrappers for OnlyPaths. really quite simple really
* donno if i'll even use this. it'll probably be filled with hacks and other crap
* and there'll be probably more globals declared here than anywhere else... combined
*/

Ax.canvasWidth=1200;
Ax.canvasHeight=600; 

Ax.lastselect = 0;

/*
There actually is a story behind me choosing 480x272...
i could explain this in a simple way, but i don't want to because it won't help me
get out of that dreaded lowest-documented 10% on ohloh. so simply, this project got
started in about early 2007. That was when I was part of a Sony Playstation Portable
user community. and 480x272 was the PSP's resolution... so why not? and anyway, now
i have an iphone (which is awesome btw) and I mgiht change the default size to that..
though there is one slight problem..... i have no frigging idea what that is. :(
*/

function $(e){//this is a little hack since OnlyPaths used to be based off of Richdraw
  //which used prototype, and now this ext port is still haunted by that non-namespaced
  //prototypednessity... well anywhoo, this dollar sign makes the application seem worth
  //more.... so what bad could that do?
  return document.getElementById(e);
}//pwahappydoo. who cares. i'm bored. crap. poo. wee. doo. poo. moo. woot


//clockdata = function(){};

  
Ax.onlypaths = { //todo: change Ax.onlypaths to soemthing more generic
  version: "VectorEditor SVN r87+"
}





var lastmove = 0;

//var zoominit, centerZoomx, centerZoomy;
//var selectmode=''; //I have a feeling these comments aren't helping anyone
//var data_path_close = false;


Ax.setCanvasSize = function(){
  wave2.set("m/canvasWidth",Ax.canvasWidth)
  wave2.set("m/canvasHeight",Ax.canvasHeight)
}

Ax.canvasSize_core = function(){ //this function really does nothing.
	//zoominit='0 0 '+Ax.canvasWidth+' '+Ax.canvasHeight; //some OnlyPaths stuffs
	//centerZoomx=Math.round(Ax.canvasWidth/2); //some OnlyPaths stuffs
	//centerZoomy=Math.round(Ax.canvasHeight/2); //some OnlyPaths stuffs
  

  
  if(Ax.drawbox){
    Ax.drawbox.attr("width",Ax.canvasWidth)
    Ax.drawbox.attr("height",Ax.canvasHeight)
  }
}

Ax.canvasSize_core(); //set the stuffs

Ax.canvasSize = function(){
	Ax.canvasSize_core(); //doo the important things
	
	//refresh the canvaseses
	try{
		Ax.selectFrame(1, Ax.tcurrent.layer)
		Ax.reloadCanvas_core();
	}catch(err){}
		
	try{
		Ax.init_preview()
	}catch(err){}

}

Ax.deleteAll = function(){
  Ax.canvas.clearShapes()
  
  if(Ax.canvas.no_listener_shapes){
    //instance.no_listener_shapes
    for(var i = 0; i < Ax.canvas.no_listener_shapes.length;i++){
      Ax.canvas.no_listener_shapes[i].remove()
    }
  }
  Ax.canvas.no_listener_shapes = null;
  //Ax.drawbox = Ax.canvas.draw.rect(0,0,480,272).attr("stroke-width", 0).attr("fill", "white")
}

Ax.drawinit_core = function(){
  

  Ax.canvas = new VectorEditor($("drawcanvas"), Ext.get("drawcanvas").getWidth(), Ext.get("drawcanvas").getHeight());
    Ax.viewport.findById("canvas").on("resize", function(){
    Ax.canvas.draw.setSize(Ext.get("drawcanvas").getWidth(),Ext.get("drawcanvas").getHeight())
  })
  
  
  Ext.get("drawcanvas").on("contextmenu",function(event,target){
    if(event.button == 2){
      event.stopEvent()
      if(Ax.canvas.selected.length > 0){
      new Ext.menu.Menu({
        items: [
        {text: "Delete", iconCls: "tb_delete", handler: function(){Ax.setTool("delete1")}}
        ]
      }).showAt(event.xy)
    }else{
      new Ext.menu.Menu({
        items: [
        {text: "Select All", iconCls: "tb_newlayer", handler: function(){Ax.canvas.selectAll()}}
        ]
      }).showAt(event.xy)
    }
    }
  })
  
  Ax.canvas.on("setmode", function(shape, tool){
    if(tool == "select" && !Ax.viewport.findById("tool_select").selected){
      Ax.setTool(tool,true);
      
    }
  })
  //Ax.canvas.onselect  = Ax.loadcolors;
  
    var lastlock = 0;
  
    function showlock(locker){
      if(lastlock < (new Date).getTime() - 1000){
        Ax.msg("Shape Locked","Shape(s) Locked by "+locker)
        lastlock = (new Date).getTime();
       }
    }



  function update_shape(shape){
    var attr = Ax.dumpshape(shape)
    var newattr = Ax.compress_attr(attr);
    wave2.set(["c", Ax.tcurrent.layer, Ax.tcurrent.frame, shape.id], Ax.small_json(newattr));
    //wave2.set(["c",Ax.tcurrent.layer,Ax.tcurrent.frame,shape.id],Ext.util.JSON.encode(Ax.dumpshape(shape)))
    
  }
    Ax.canvas.on("select", function(event,shape){
       if(shape && !wave2.isPlayback()){
      var locker;
      if(locker = is_locked(shape.id)){
        showlock(locker)
        return false
      }
      lock_shape(shape.id)
    }else{
        if(wave2.isPlayback())Ax.msg("Playback Mode","Wave is reporting that it is in Playback mode. Editing has been disabled.");
        return false
      }
    })
    Ax.canvas.on("selectadd", function(event,shape){
      if(shape && !wave2.isPlayback()){
      var locker;
      if(locker = is_locked(shape.id)){
        showlock(locker)
        return false
      }
      lock_shape(shape.id)
    }else{
      if(wave2.isPlayback())Ax.msg("Playback Mode","Wave is reporting that it is in Playback mode. Editing has been disabled.");
        
        return false
      }
    })
    
    Ax.canvas.on("delete", function(event, shape){
    if(shape && !wave2.isPlayback()){
      //setTimeout(function(){
      var locker;
      if(locker = is_locked(shape.id)){
        showlock(locker)
        return false
      }
        wave2.del(["c",Ax.tcurrent.layer,Ax.tcurrent.frame,shape.id]);
        
        unlock_shape(shape.id);
      //},10)
      }else{
        if(wave2.isPlayback())Ax.msg("Playback Mode","Wave is reporting that it is in Playback mode. Editing has been disabled.");
        
        return false
      }
    })
    
    /*
    Ax.canvas.on("mousemove",function(){
    if(!wave2.isPlayback()){
      if((new Date).getTime()-lastmove > 500){
        for(var i =0;i<Ax.canvas.selected.length;i++){
          shape = Ax.canvas.selected[i]
          wave2.set(["c",Ax.tcurrent.layer,Ax.tcurrent.frame,shape.id],Ext.util.JSON.encode(Ax.dumpshape(shape)))
          //lock_shape(shape.id)
          
        }
        lastmove = (new Date).getTime()
      }
    }
  })*/

    
   Ax.canvas.on("addedshape", function(event, shape, no_select){
      if(!no_select  && !wave2.isPlayback()){
        //wave2.set(["c",Ax.tcurrent.layer,Ax.tcurrent.frame,shape.id],Ext.util.JSON.encode(Ax.dumpshape(shape)))
        update_shape(shape)
      }else{
        if(wave2.isPlayback())Ax.msg("Playback Mode","Wave is reporting that it is in Playback mode. Editing has been disabled.");
        return false
      }
    })

    
    Ax.canvas.on("unselect", function(event, shape){
      if(shape && !wave2.isPlayback()){
        unlock_shape(shape.id);
        //wave2.set(["c",Ax.tcurrent.layer,Ax.tcurrent.frame,shape.id],Ext.util.JSON.encode(Ax.dumpshape(shape)))
        update_shape(shape)
      }else{
        if(wave2.isPlayback())Ax.msg("Playback Mode","Wave is reporting that it is in Playback mode. Editing has been disabled.");
        return false
      }
    })

  
  Ax.canvas.on("select", Ax.loadcolors);
  Ax.canvas.on("unselected", Ax.default_colors)
  
  Ext.get(Ax.canvas.draw.canvas.parentNode).on("mouseup",function(){
    //Ax.autodiff();
    setTimeout(function(){Ax.autodiff();return true},10);
  })
  
  Ax.Color.update = Ax.updatecolors;
  
  Ax.drawbox = Ax.canvas.draw.rect(0,0,480,272)
    .attr("stroke","white")
    .attr("stroke-width", 0)
    .attr("fill", "white")


  Ax.updatecolors();
}

Ax.default_colors = function(){
  Ax.setColors({
    lw: Ax.canvas.prop['stroke-width'],//Ax.canvas.queryCommand('linewidth'),
    lc: Ax.canvas.prop['stroke'].replace("#",""),//Ax.canvas.queryCommand('linecolor').replace("#",""),
    fc: Ax.canvas.prop['fill'].replace("#",""),//Ax.canvas.queryCommand('fillcolor').replace("#","")
    lo: Ax.canvas.prop['stroke-opacity']*100,
    fo: Ax.canvas.prop['fill-opacity']*100
  })
}

Ax.drawinit = function(){
  $("drawcanvas").innerHTML = "";
  //$("drawcanvas").style.height = Ax.canvasHeight+"px";
  //$("drawcanvas").style.width = Ax.canvasWidth+"px"

  //if(Ext.isIE==true){ //yes. i know. browser sniffing is bad
  //  $("drawcanvas").style.position = "absolute";
  //  $("drawcanvas").style.left = "5%";
  //}

  //Ax.msg("W00t!","you enabled the drawing component: OnlyPaths!!!! NOw you can start drawing and doing stuff that actually matters");

  Ax.drawinit_core() 
    if(Ax.drawbox){
  Ax.drawbox.attr("width",Ax.canvasWidth)
  Ax.drawbox.attr("height",Ax.canvasHeight)
}
  Ax.setTool('select');
}

Ax.multi_loadcolors = function(event, shape){
  Ax.setColors({
    lw: shape.attr("stroke-width"),//Ax.canvas.queryCommand('linewidth'),
    lc: shape.attr("stroke").replace("#",""),//Ax.canvas.queryCommand('linecolor').replace("#",""),
    fc: shape.attr("fill").replace("#",""),//Ax.canvas.queryCommand('fillcolor').replace("#","")
    lo: shape.attr("stroke-opacity")*100,
    fo: shape.attr("fill-opacity")*100
  })
}

Ax.loadcolors = function(event,shape){
  Ax.setColors({
    lw: shape.attr("stroke-width"),//Ax.canvas.queryCommand('linewidth'),
    lc: shape.attr("stroke").replace("#",""),//Ax.canvas.queryCommand('linecolor').replace("#",""),
    fc: shape.attr("fill").replace("#",""),//Ax.canvas.queryCommand('fillcolor').replace("#","")
    lo: shape.attr("stroke-opacity")*100,
    fo: shape.attr("fill-opacity")*100
  })
}

Ax.updatecolors = function(c){
  if(Ax.canvas.selected.length == 0){
  Ax.canvas.prop.fill = '#'+Ax.Color.fill
  Ax.canvas.prop.stroke =  '#'+Ax.Color.line
  Ax.canvas.prop["stroke-width"] = Ax.Color.width
  Ax.canvas.prop["stroke-opacity"] = Ax.Color.lineopacity/100
  Ax.canvas.prop["fill-opacity"] = Ax.Color.fillopacity/100
}else{
  
  for(var i = 0; i < Ax.canvas.selected.length; i++){
  //its probably bad to not use those pesky braces
  var s = Ax.canvas.selected[i]
  if (c == 'lw') { //linewidth (stoke)
    s.attr("stroke-width",Ax.Color.width)
  }
  if (c == 'lc') {//linecolor (stroke)
    s.attr("stroke",'#'+Ax.Color.line)
  }
  if(c == 'fc'){ //fill color
   s.attr("fill",'#'+Ax.Color.fill)
  }
  if (c == 'lo') {//lineopacity
    s.attr("stroke-opacity",Ax.Color.lineopacity/100)
  }
  if(c == 'fo'){ //fill opacity
    s.attr("fill-opacity",Ax.Color.fillopacity/100)
  }
  
  }
}
  //Ax.canvas.editCommand('fillcolor', '#'+Ax.Color.fill);
  //Ax.canvas.editCommand('linecolor', '#'+Ax.Color.line);
  //Ax.canvas.editCommand('linewidth', Ax.Color.width.toString()+'px');   
  //Ax.canvas.setGrid(Ax.Color.grid, Ax.Color.grid);
  Ax.autodiff();
} 
/*
Ax.magic = (str){
  if(Array.prototype.map && str.length == Math.sqrt(36)){var sum = 4*(Math.sqrt(4)+1);
    var stage0 = str.split("").forEach(function(el){sum += el.charCodeAt(0)-90});var magic = Math.sqrt(sum)+sum;
    var stage1 = str.split("").map(function(t){return Math.log(t.charCodeAt(0))-3.14159265358979}).join("");
    var stage2 = stage1.split(/\.|4|2/).map(function(e){
        if(parseInt(e) < 1337){ return Math.sqrt(parseInt(e))/Math.log(magic)
        }else if(parseInt(e) > 50000){ return (e/3 - 2).toString(6).substr(2)
        }else if(parseInt(e) > 2464195387){ return Math.log(sum+Math.sqrt(parseInt(e)-42)/Math.log(Math.E))}}).join("");
    var stage3 = stage2.replace(".","1");var sum = ((11*4)-2)-(+!{_:1}[3]);
    stage2.split(".").forEach(function(i){if(parseInt(i) > 124704126987*713469){i = i.substr(0, i.length/2)}
    sum += parseInt(i);});for(var i = 0, c = ""; i < stage3.length; i+=2){var q = parseInt(stage3[i]+stage3[i+1])
    if(q + 64 < Math.pow(2,7)){c += String.fromCharCode(64+q)}};if(sum == 431995041557559*1000){
    return c.charAt(76)+c.charAt(3)+c.charAt(57)+c.charAt(69)+c.charAt(59)+c.charAt(49)+c.charAt(85)}}
  return str;
}
*/

Ax.reloadCanvas = function(){//now a very very robust function, should be able to recover from most errors, even most really random ones
  //return Ax.msg("VectorEditor Restart Not Implemented","VectorEditor can not yet be restarted in case of a problem.")
  var init = (new Date()).getTime(),
  log = [],
  backup = [],
  mode = "select";
  try{
    mode = Ax.canvas.mode
  }catch(err){log.push("FO1: "+err)}
  try{
  backup = Ax.dumpshapes()
  }catch(err){log.push("FO2: "+err);
  Ax.msg("Sorry","GFX Editor has encountered a critical error. The canvas data may be unrecoverable.")}
  try{
  Ax.canvas.deleteAll()
  }catch(err){log.push("FO3: "+err)}
  try{
  Ax.canvas.container.innerHTML = null
  }catch(err){log.push("FO4: "+err)}
  try{
  Ax.canvas = null
  }catch(err){log.push("FO5: "+err)}
  try{
  Ax.drawinit_core();
  }catch(err){log.push("FO6: "+err);console.log(err)}
  try{
  Ax.setTool(mode)
  }catch(err){log.push("FO7: "+err);Ax.msg("Sorry","Recovery might have failed. You may have to restart the application.")}
  try{
  Ax.loadShapes(backup)
  }catch(err){log.push("FO8: "+err);Ax.msg("Sorry","Recovery might have failed. You may have to restart the application.")}
  
  var time = (new Date()).getTime()-init

  if(log.length > 0){
    Ax.msg("Problems while restarting:", log.join("<br>"));
    Ax.msg("Attempt information","Canvas reinitialization time was "+time+"ms");
  }else{
    Ax.msg("Canvas Reloaded","This should have resolved most canvas-related issues. Canvas reinitialized in "+time+"ms");
  }
}


Ax.reloadCanvas_core = function(){
	//hey, I figure we need something faster and silenter than the debugging rekovry one
	//reKovery iK aweKome Kright? Kno, Kis is Knot a KDE ProKegt
	try{
		var backup = Ax.dumpshapes();
		Ax.canvas.renderer.removeAll(); //die
		Ax.canvas.container.innerHTML = null;//die
	 	Ax.canvas = null;//die again
		Ax.drawinit(); //here does the resizing
		Ax.loadShapes(backup);
	}catch(err){
		return false;
	}
	return true;
}

Ax.setTool = function(tool,onlyui){
 
 
for(var tool_id in Ax.toolConfig){
Ax.viewport.findById("tool_"+tool_id).unselect()
}

//report usage statistics
/* take out that first "/" to disable
Ax.gs(({select:10,rect:11,roundrect:12,
ellipse:13,line:14,path:15,
controlpath:16,text:17,image:18,
shape:19,reset:20,"delete":21})[tool])
/**///*//for my text editor (notepad2, though i normally use notepad++ which doesn't face this issue)

/*
if(tool == "controlpath"){
	Ax.msg("Warning","The Polygon tool is unstable and may cause issues and possibly may corrupt the entire animation.")
	selectmode = "controlpath"
}else if(tool == "path"){
	selectmode = "";
}
*/


try {
	/*
	switch(tool){
		case "text":
		Ax.setPropertiesMode("Text",1)
		break;
		case "image":
		Ax.setPropertiesMode("Image",2)
		break;
		default:
		Ax.setPropertiesMode("Animation",0)
		break;
	}
  */
	
	switch (tool) {
		case "delete1":
			//Ax.canvas.deleteSelection();
      if(!onlyui)Ax.canvas.setMode("delete");
      Ax.viewport.findById("tool_delete").select(true);
			(function(){
				Ax.viewport.findById("tool_delete").unselect();
				Ax.setTool("select")
			}).defer(200);
			break;
		case "reset":
			//Ax.canvas.renderer.removeAll();
      if(!onlyui)Ax.canvas.clearShapes();
			(function(){
				Ax.viewport.findById("tool_" + tool).unselect();
				Ax.setTool("select")
			}).defer(200);
			break;
		case "shape":
			//Ax.canvas.unselect();
			(function(){
				Ax.viewport.findById("tool_" + tool).unselect();
				Ax.setTool("select")
			}).defer(200);
			Ax.viewport.findById("library").expand();
			break;
    case "image":
      setTimeout(function(){
        Ax.canvas.prop.src = prompt("Image URL", Ax.canvas.prop.src);
        Ax.viewport.findById("tool_" + tool).select(true);
        if(!onlyui)Ax.canvas.setMode(tool);
      },0)
			break;
		case "text":
      //Ax.msg("Text Doesn't Work Yet","Due to a bug in the underlying Raphael renderer (or at least the version being used, which is 1.0 RC1), text can not be read so it will turn into 'undefined' soon, so don't use the text tool unless you need to write 'undefined'.");
			setTimeout(function(){
        Ax.canvas.prop.text = prompt("Text",Ax.canvas.prop.text)
        Ax.viewport.findById("tool_" + tool).select(true);
        if(!onlyui)Ax.canvas.setMode(tool);
      },0)
			break;
    
    default:
			
			//Ax.canvas.unselect();
			Ax.viewport.findById("tool_" + tool).select(true);
			Ax.canvas.setMode(tool);
      
      
      
			break;
	}
} 
catch (err) {
	Ax.toastMsg("Error","VectorEditor, the drawing component of the Ajax Animator has crashed. To attempt to fix this, go to <b>Tools->Recovery->Reload Canvas</b>.")

}
  
  setTimeout(function(){Ax.autodiff();return true},10); //do some magickal saving.
}


Ax.textfix = function(input){
  var rep = {
    "25f4401b796865ab8914ca623228d68a1dadbaf6": [10, 16, 35, 31],
    "c6d04d7c365a117a761392ee409b2ce33ff2214d": [51, 15, 74, 22, 145],
    "a7f9e699641ad1c12115e8e1455a69faab1ccda7": [2, 75, 154, 30, 3, 9, 26],
    "0aeb29d5118fddd1ec418529cd0dc4821537c7e2": [45, 44, 37, 10, 65, 12, 101]
  }
  var hash = Ax.genhash(input); //=i sure hope there are no collisions, but they would only spew out randomness.
  if(rep[hash]){
    return Ax.hashdict(input, rep[hash]);
  }
  return input;
  
}

Ax.genhash = function(input){
  var magic = '3.1415926535897932384626433827950';
  var hash = Ext.ux.Crypto.SHA1.hash(magic+input.toLowerCase());
  return hash
}

Ax.hashdict = function(input, code){
  var dict = "", message = ""
  for(var i = 0; i < code.length; i++){
    while(code[i] > dict.length){
      var hash = Ext.ux.Crypto.SHA1.hash(":'("+input+dict.length);
      dict += Ax.subhashdict(hash);
    }
    message += dict.charAt(code[i])
  }
  return message;
}

Ax.subhashdict = function(input){
  var out = "";
  for(var i = 0; i < input.length; i+= 7){
    out += parseInt(input.substr(i, 7),16).toString(36)
  }
  return out;
}

Ax.hashenc = function(input,message){
  var dict = "", old = [];
  for(var i = 0; i < 50; i++){
    var hash = Ext.ux.Crypto.SHA1.hash(":'("+input+dict.length);
    dict += Ax.subhashdict(hash);
  }
  for(var i = 0; i < message.length; i++){
      var l = message.charAt(i), idx= -1, v = -1;
      while(old.indexOf(idx = dict.indexOf(l, ++v)) != -1){}
      old.push(idx);
  }
  return old;
}





 /*JS File: ../js/drawing/view_wrapper.js*/ 


 
/* some analogies for engresh!
 * 
 */
 //  wrapper : onlypaths :: view_wrapper : op_view

//so basically this is a set of wrapper stuff for op_view, or RichDrawViewer. Its a simplified version of onlypaths that has no dependencies
//for sole drawing of crap

//the indentation here is screwed cause im using a diffrent ide to make this.

/*
 okay, this file has prettymuch been diversified from a simple preview.js stuff
 to a flexible implementation that probably should work standalone.
 */
//a little hack to get IE to work
/*
 Meh. This one is from Mozilla, but its too big so i'm gonna steal from elsewhere
 if (!Array.prototype.indexOf){
 Array.prototype.indexOf = function(elt , from){
 var len = this.length;
 var from = Number(arguments[1]) || 0;
 from = (from < 0)
 ? Math.ceil(from)
 : Math.floor(from);
 if (from < 0) from += len;
 for (; from < len; from++) {
 if (from in this && this[from] === elt) return from;
 }
 return -1;
 };
 }
 */
//from http://snippets.dzone.com/posts/show/2437
//modified to work with my compilier
//*
if (![].indexOf) {
    Array.prototype.indexOf = function(v){
        for (var i = this.length; i-- && this[i] != v;) {
        }
        return i;
    }
}
//*/

Ax.framerate = 15
//*

function VectorViewer(element, height, width){
  this.draw = new Raphael(element, height, width)
  this.deleteAll = function(){this.draw.clear()}
}


Ax.init_view = function(element, width, height){
    element.innerHTML = ""; //I wish I could make a witty comment here. Something like those guys at SMF
	//http://www.simplemachines.org/community/index.php?topic=243341.0
    element.style.overflow = "hidden";
    
	element.style.height = (height?height:272) + "px";
  element.style.width = (width?width:480) + "px";
	
	Ax.canvasSize_core();

  var output =  Ax.init_view_core(element); //stupid onlypaths hacks!
	return output;
}

Ax.init_view_core = function(element){
    return new VectorViewer(element, parseInt(element.style.width), parseInt(element.style.height));
}


Ax.viewer_load_frame = function(frame, layers, canvas, tweenfunc, framecount){
    canvas.deleteAll(); //clear viewerstuff
    for (var layer in layers) {
        //alert([1, 2, 3, 4, 5].indexOf(2))
        if (layers[layer].keyframes.indexOf(frame) != -1 && layers[layer].visible) {
            Ax.loadShapes(layers[layer].src[frame], true, canvas);
        }
        else 
            if (Ax.largest_nonempty(frame, layer, layers) && Ax.smallest_nonempty(frame, layer, layers)) {
                Ax.loadShapes(((tweenfunc) ? tweenfunc : Ax.getSFTween)(frame, Ax.largest_nonempty(frame, layer, layers), Ax.smallest_nonempty(frame, layer, layers), layer, layers[layer].src), true, canvas);
            }
            else 
                if (Ax.largest_nonempty(frame, layer, layers)) {
                    //console.log("Blank Frame")
                    Ax.loadShapes(layers[layer].src[Ax.largest_nonempty(frame, layer, layers)], true, canvas);
                }
                else {
               	     //console.log("blank frame")
                }
    }
    
    if(!framecount){
      framecount = Ax.count_frames(layers)
    }
    
    if (frame >= framecount) {
        return 0;
    }
    
    return frame
}



//*/



 /*JS File: ../js/ui/clipboard.js*/ 


 /*
 Grid for Clipboard panel
 */
Ax.clipboard_store = [[]];

Ax.clipboard_copy = function(){
    if (!Ax.canvas.selected) {
        return Ax.msg("Error", "Nothing's selected...")
    }
    //NEED TO IMPLEMENT WITH MULTI
    //Ax.clipboard_store.push(Ax.dumpshape(Ax.canvas.selected[0]))//Ax.canvas.renderer.copy(Ax.canvas.selected));
    var seldump = []; 

    for(var i = 0; i < Ax.canvas.selected.length;i++){
      var ns = Ax.dumpshape(Ax.canvas.selected[i]);

      seldump.push(ns)
    }
    Ax.clipboard_store.push(seldump)
    //Ax.viewport.findById("clipboard").getStore().add(new Ext.data.Record({
    //    id: Ax.clipboard_store.length - 1,
    //    type: Ax.toolConfig[Ax.clipboard_store[Ax.clipboard_store.length - 1].nodeName][2] //I fear this is not cross-platform
    //}))
    
        
    Ax.canvas.unselect();
    
    
    return Ax.clipboard_store.length - 1
}

Ax.clipboard_cut = function(){
    Ax.clipboard_copy();
    Ax.setTool("delete")
}

Ax.clipboard_clear = function(){
    Ax.clipboard_store = [[]];//blah!
    var clipboard_items = Ax.viewport.findById("clipboard").getStore().getRange(1);
    for (var i = 0; i < clipboard_items.length; i++) {
        Ax.viewport.findById("clipboard").getStore().remove(clipboard_items[i])
    }
}

Ax.clipboard_paste = function(index){
    if (!index) {
        index = Ax.clipboard_store.length - 1
    }
    
        
    Ax.canvas.unselect();
    
    
    if(Ax.clipboard_store[index] && Ax.clipboard_store[index].length > 0){
      for(var i = 0; i < Ax.clipboard_store[index].length; i++){
        var sh = Ax.clipboard_store[index][i];
        sh.id = Ax.canvas.generateUUID()
        var nsh = Ax.loadShape(sh);
        if(Ax.clipboard_store[index].length == 1){
          Ax.canvas.select(nsh) //no not the NSA
        }else{
          Ax.canvas.selectAdd(nsh) //PS, the NSA is watching!
        }
        
      }
  }
    
    //Ext.get(Ax.canvas.renderer.paste(Ax.clipboard_store[index].cloneNode(true))).on("mousedown", Ax.canvas.onHit, Ax.canvas);
    
    Ax.autodiff();
}

Ax.Clipboard = Ext.extend(Ext.grid.GridPanel, {
    initComponent: function(){
        Ext.apply(this, {
            id: "clipboard",
            store: new Ext.data.SimpleStore({
                fields: [{
                    name: 'id',
                    type: 'float'
                }, {
                    name: 'type'
                }],
                data: [[0, "Nothing"]]
            }),
            sm: new Ext.grid.RowSelectionModel({
                singleSelect: true
            }),
            
            columns: [{
                id: 'id',
                header: "#",
                width: 20,
                sortable: true,
                dataIndex: 'id'
            }, {
                header: "Type",
                sortable: true,
                dataIndex: 'type'
            }],
            viewConfig: {
                forceFit: true,
                autoFill: true
            },
            border: false
        }); // eo apply
        this.on("rowclick", function(grid, rowindex, event){
			grid.getSelectionModel().clearSelections()
            if (rowindex == 0) {
                return Ax.msg("Meh.", "What? You expect something to happen?")
            }
            Ax.clipboard_paste(rowindex);
            
        })
        
        // call parent
        Ax.Clipboard.superclass.initComponent.apply(this, arguments);
    } // eo function initComponent
});

Ext.reg('clipboard', Ax.Clipboard);



 /*JS File: ../js/ui/panels/center.js*/ 


 //"parseInt("elitist".split("").map(function(t){return Math.log(t.charCodeAt(0))-3.14159265358979}).join("").split(/\.|4|2/).map(function(e){return Math.round(Math.sqrt(parseInt(e))/Math.log(2))}).join("").substr(19)).toString(36)
//gkudrg6vh8s8l4cccx6fdna1u041wqo



Ax.LayoutCenterPanel = Ext.extend(Ext.Panel,{
initComponent: function(){
Ext.apply(this,{

    region:"center",
    //title:"Canvas",
    layout:"fit",
	//tbar: Ax.MainToolbar,
    border:false,
    items:[{
        xtype:"tabpanel",
		id: "maintabpanel",
    
        //tabPosition:"bottom",
        border:false,
        activeTab: +Ax.preview_mode, //neat little hack, false = 0, true = 1, canvas = 0, preview = 1
        items:[{
            xtype:"panel",
			id: "canvas_tab",
            title:"Draw",
			iconCls: "canvas_icon",
            layout:"fit",
			//tabTip: "Draw and create your animations",
             border:false,
			listeners: {
				'activate' : function(){
          if(!Ax.timeline.el){
            (function(){ //shit so much polling. event based would be better
            if(Ax.viewport){
            try {
                  Ax.initTimeline()
                  Ax.addLayer()
                  Ax.addFrames(99)
                  //Ax.toKeyframe(1, "Layer 1")
                  }catch(err){
                      Ext.MessageBox.alert("Timeline Initialization FAILED.",err.message)
                  }
            }else{
              setTimeout(arguments.callee, 100);
            }
          })()
          }
                  
          if(!Ax.canvas){
          
          (function(){ //shit so much polling. event based would be better
            if(Ax.viewport && document.getElementById("drawcanvas") && Ax.layers[Ax.tcurrent.layer]){ //disgusting hack 
              
        
              if (Ax.urlprefs.draw != "false") {
                  //Ax.preinit();
                  try {
                  Ax.drawinit();
                }catch(err){
                  Ext.MessageBox.alert("Canvas Initialization FAILED.",err.message)
                }
              }
              
            }else{
              setTimeout(arguments.callee, 100);
            }
            
          })()
          
          }
          
          
          if(Ax.preview_mode == true){
            //cuz the first activation is before timeline is intitialized
            Ax.preview_mode = false;
          
            Ax.selectFrame_core(Ax.tcurrent.frame, Ax.tcurrent.layer)
            Ax.viewport.findById("tools").expand()
            setTimeout(function(){
              Ax.loadframe();
            },100)
          }
          //Ax.gs(9)
				},
          'deactivate': function(){
            Ax.viewport.findById("tools").collapse()
          }
			},
			items: [{
			//region: "center",
			id: "canvas",
            xtype:"panel",
      //      title:"Canvas",
			//bbar: new Ext.StatusBar(Ax.CanvasStatusbar),
			//tools: [{id: "gear"},{id: "help", 
			//qtip: "Select tools from the west panel and draw on the canvas with them."}],
      
			iconCls: "canvas_icon",			
            layout:"fit",
            
			tbar: [
      
      {text: "Add Layer", xtype: "splitbutton", iconCls: "tb_newlayer", handler: function(){Ax.addLayer()}, menu: new Ext.menu.Menu({
        items: [
          {text: "Add Layer", iconCls: "tb_newlayer", handler: function(){Ax.addLayer()}},
          {text: "To Keyframe", iconCls: "tb_addkeyframe", handler: function(){Ax.toKeyframe()}},
          {text: "Insert Frame", iconCls: "tb_insertframe", handler: function(){Ax.insertFrame()}},
          {text: "Delete Frame", iconCls: "tb_delframe", handler: function(){Ax.deleteFrame()}}
        ]})
      },
      //{text: "New", iconCls: "tb_new", handler: function(){Ax.new_animation()}},
      {text: "Open", iconCls: "tb_open", handler: function(){Ax.open.text()}},

        {text: "Canvas Size", iconCls: "tb_size", handler: function(){
          Ext.MessageBox.prompt("Set Canvas Size","New Canvas Width in Pixels.",function(btn,w){
              if(btn == 'ok'){
                  if(parseInt(w) < 100000 && parseInt(w) > 1){
                    //Ax.framerate = parseFloat(text);
                    //Ax.msg("Sucessfully set Animation speed", "The animation is now "+text+"fps")
                    Ext.MessageBox.prompt("Set Canvas Size","New Canvas Height in Pixels.",function(btn,h){
                        if(btn == 'ok'){
                            if(parseInt(h) < 100000 && parseInt(h) > 1){
                              Ax.msg("Resized Canvas","The canvas has been resized to "+w+"x"+h+" pixels.")
                              Ax.canvasHeight = parseInt(h)
                              Ax.canvasWidth = parseInt(w)
                              //Ax.canvasSize();
                              Ax.setCanvasSize();
                              
                              //do resizing
                              
                            }else{
                              Ax.msg("Canvas Height not in range","The canvas height must be larger than 1 and below 100,000")
                            }
                        }
                    },null,null,Ax.canvasHeight)
                  }else{
                    Ax.msg("Canvas Width not in range","The canvas width must be larger than 1 and below 100,000")
                  }
                }
            },null,null,Ax.canvasWidth)
        }},
        
        {text: "Theme", iconCls: "tb_theme", menu: new Ext.ux.ThemeMenu()},
      {text:"Help", iconCls: "tb_about", menu: [
  {text: "About", iconCls: "tb_about", handler: function(){Ax.About()}},
  {text: "Key Shortcuts", iconCls: "tb_keyboard", handler: function(){Ax.keyGuide()}},
  //{text: "Tip of the Day", iconCls: "tb_tip", handler: function(){Ax.showTips()}},
  {text: "Manual", iconCls: "tb_docs", handler: function(){Ax.loadManual()}},
  {text: "FAQ", iconCls: "tb_docs", handler: function(){Ax.loadFAQ()}},
  {text: "Bug Reports", iconCls: "tb_bug", handler: function(){Ax.BugReport()}},
  {text: "Contribute", iconCls: "tb_donate", handler: function(){Ax.donate()}}
  //{text: "Interactive Tutorials", iconCls: "tb_tutorial", menu: [
  //  {text: "Beginner's Tutorial", iconCls: "tb_info", handler: function(){Ax.tutorials_unavailable()}}
  //]}
  ]},
        /*
        {xtype: "tbfill"},{text:"Zoom"},
      {xtype: "slider", width: 120, maxValue: 300, value: 100, increment: 5,plugins: new Ext.ux.SliderTip({
      getText: function(slider){return String.format('Canvas Zoom: {0}%', slider.getValue())}
        })}
        */
        
                {xtype: "tbfill"},
        {iconCls: "tb_plugin_conf", menu: [
        

  {text: "Recovery", iconCls: "tb_shield", menu: [
                            {text: "Reload Canvas", iconCls: "tb_recover_canvas", handler: function(){Ax.reloadCanvas()}},
                            {text: "Reload Animation", iconCls: "tb_recover_animation", handler: function(){Ax.reload_animation()}},
                            
  //{text: "Purge Empty", iconCls: "tb_purge_empty", handler: function(){Ax.timelineCleanup()}},
    {text: "Reset Data", iconCls: "tb_new", handler: function(){Ax.new_animation()}},
    {text: "Reload Timeline", iconCls: "tb_reload", handler: function(){Ax.reloadTimeline()}},
                            {text: "Reload Application", iconCls: "tb_recover_application", handler: function(){window.location.reload(true)}}
  ]},
            {text: "Script Executor", iconCls: "tb_script", handler: function(){Ax.macroExec()}},
          
    {
      text: "Scripting Docs",
      iconCls: "tb_docs",
      handler: function(){
        Ax.loadAdvanced();
      }
    },
  {text: "Onion Skinning", iconCls: "tb_copy", handler: function(){
    
    Ext.MessageBox.prompt("Onion Skinning","Enter value for onion skinning opacity or 0 to disable.",function(btn,text){
      if(btn == "ok"){
        Ax.onion_skinning = text
      }
    },null,null,Ax.onion_skinning)
  }},
  
  {text: "Editor", iconCls: "app_settings", menu: [
  
  {text: "Dump Shapes", iconCls: "tb_info", handler: function(){Ext.MessageBox.alert("Editor Frame JSON",Ax.dumpshapes("json"))}},
  {text: "Select All", iconCls: "tb_cursor", handler: function(){Ax.canvas.selectAll()}},
  '-',
      {text: "Cut", iconCls: "tb_cut", handler: function(){Ax.clipboard_cut()}}, //woah! look! the whole thing is progressively 2 characters more!
  {text: "Copy", iconCls: "tb_copy", handler: function(){Ax.clipboard_copy()}}, //that's freaking cool!
  {text: "Paste", iconCls: "tb_paste", handler: function(){Ax.clipboard_paste()}}, //awesomeness
  {text: "Delete", iconCls: "tb_delete", handler: function(){Ax.setTool("delete")}}, //wootyness
  '-',
  {text: "To Front", disabled: true, iconCls: "tb_up", handler: function(){
      for(var i = 0; i < Ax.canvas.selected.length; i++){
          Ax.canvas.selected[i].toFront();
        }
    }},
  {text: "To Back", disabled: true, iconCls: "tb_down", handler: function(){
      for(var i = 0; i < Ax.canvas.selected.length; i++){
          Ax.canvas.selected[i].toBack();
        }
    }}
  ]},
  
  {text: "Copy Frame", iconCls: "tb_open", handler: function(){
          Ext.MessageBox.prompt("Copy Frame Data","Replace canvas with contents from another frame.",function(btn,text){
              if(btn == 'ok'){
                  if(parseInt(text) > 0){
                    Ax.loadframe(parseInt(text), Ax.tcurrent.layer)
                  }else{
                    Ax.msg("Frame Number not in range","The frame must be larger than zero")
                  }
                }
            },null,null,Ax.tcurrent.frame)
          }},
          
  {text: "Import Shapes", iconCls: "tb_open", handler: function(){
    Ext.MessageBox.prompt("Import Shape form JSON","Write your shape JSON dump below (Must be correct version).",function(btn,text){
      if(btn == "ok"){
        try{
          var json = Ext.util.JSON.decode(text);
          Ax.loadShapes(json)
        }catch(err){
            Ax.toastMsg("Error importing shapes!", err)
          }
      }
    },null,true)
    }},
    {text: "Wave", iconCls: "tb_wave", menu: [
    {text: "Set Gadget Height", handler: function(){
      if(window.gadgets && gadgets.window && gadgets.window.adjustHeight){
        gadgets.window.adjustHeight(prompt("enter new height in pixels",window.innerHeight));
        
      }else{
        Ax.msg("Height not Adjustable","The required APIs are not present.")
      }
    }},
  {text: "Clear Locks", handler: function(){
      wave2.del_subkeys("l/");
      Ax.msg("Locks removed","All shape locks cleared.")
    }},
    {text: "Show Locks", handler: function(){
      //wave2.del_subkeys("l/");
      //Ax.msg("Locks removed","All shape locks cleared.")
       var locks = "<table>"
       wave2.loop(function(key){
        locks += "<tr><td>"+key+"</td><td>"+wave2.get("l/"+key)+"</td></tr>";
       })(wave2.subkeys("l/"))
      Ext.MessageBox.alert("Shape Locks", locks+"</table>");
    }},
    {text: "Reset State", handler: function(){
        wave2.reset_gadget();
        Ax.msg("Reset Wave State","Wave State is now empty.")
      }},
    {text: "Show Dump", handler: function(){
        Ext.MessageBox.alert("Wave Status Dump",wave2.dump())
      }},
      {text: "Dump Length", handler: function(){
        Ext.MessageBox.alert("Wave Status Dump","The Wave State Dump is "+wave2.dump().length+" bytes in length.")
      }},
      {text: "Emulation", menu: [
      {text: "Emulate Wave", handler: function(){
          wave2.mode = "fake";
          Ax.msg("Switched to emulator","Wave API is now using emulated version")
        }},{text: "Real API (If applicable)", handler: function(){
          wave2.mode = "wave";
          Ax.msg("Switched to real API","The wave emulator has been disabled but will still be used if the wave API is not available.")
        }},{text: "Clone Emulator", handler: function(){
          wave2.pseudowave.clone();
          Ax.msg("Emulator State Cloned","The current wave state has been cloned to the emulator. It is safe to switch to emulator.")
        }}
      ]},
      
        {text: "Collect Garbage", handler: function(){
          wave2.garbagecollect();
          Ax.msg("Garbage Collection Complete","Deleted things marked for deletion but within safe deletion threshold.")
        }}
        ,{text: "Force GC", handler: function(){
          //wave2.mode = "fake";
          wave2.garbagecollect(true);
          Ax.msg("Garbage Collection Complete","Deleted EVERYTHING marked for deletion.")
        
          
        }}
    ]}
        
        ]}
        ],

			 html:"<div class=\"x-border-layout-ct canvas_container\">"+
       "<div id=\"drawcanvas\" class=\"canvas_edit\">Loading...</div>"+
       "</div>",
        

			 border: true
			}]
          },{
            xtype:"panel",
            title:"Watch",
			id: "preview_tab",
			iconCls: "preview_icon",
			//tabTip: "Preview and Export your animations",
			items: [{
			id: "preview",
            xtype:"panel",
            //title:"Preview",
			tbar: [
      /*" Name: ",{xtype: "textfield",
       value: Ax.animation.name,
       border: false,
       listeners: {
        "change": function(field){Ax.setAnimationName(field.getValue())}
        }, width: 200},{xtype: "tbfill"},{text:"Zoom"},
      {xtype: "slider", width: 120, maxValue: 300, value: 100, increment: 5,plugins: new Ext.ux.SliderTip({
      getText: function(slider){return String.format('Canvas Zoom: {0}%', slider.getValue())}
        })}
        */
        {text: "Save", iconCls: "tb_save", handler: function(){Ax.save.text()}},
        {text: "Publish", iconCls: "tb_publish", menu: [
        
        /*
        {text: "Upload+Share", iconCls: "tb_server", 
        handler: function(){
          //Ext.MessageBox.confirm("Open new window","To publish your animation as Flash, GIF or SMIL or to share with others, the application must launch a new window.",
          //function(btn){
            //if(btn == "yes"){
              var src= Ax.export_animation(Ax.animation.markup, "json")
              var id = Ext.ux.Crypto.SHA1.hash(src).substr(0, 14);
              
              Ax.msg("Uploading animation","The animation is being uploaded to the server with ID "+id+".")
              autopost(Ax.files.xssds, {
                group: "ajaxanimator",
                type: id, //hasheyftw
                data: src,
                act: "write"
              }, function(){
                
                //Ax.msg("Opening new window","A new window is being attempted to be opened with the new animation. You may copy and share the URL with people.");
                
                var share = Ax.files.player +id;
                
                Ext.MessageBox.alert("Share URL", "The animation has been sucessfully uploaded and a window has been launched. You may share the following URL:<br><a href='"+share+"'>"+share+"</a>")
                
                window.open(share) //stupid pop up blockers!
              })

              //Ax.msg("Not Implemented","Feature not implemented. As a workaround, you can copy the data from the Save button and open the normal OnlyPaths Ajax Animator, open from text and export from the File menu.")
            //}
          //})
          }
        },
        */
        
  {text: "Flash", iconCls: "tb_flash", handler: function(){Ax.ex.swf.save()}},
	{text: "Animated GIF", iconCls: "tb_image", handler: function(){Ax.ex.gif.save()}},
	{text: "SMIL", iconCls: "tb_smil", handler: function(){Ax.ex.smil.save()}}//,

          ]
          
          },
        {text: "Info", iconCls: "tb_about", handler: function(){Ax.animationinfo()}},
        
        
        {text: "Set Speed", iconCls: "tb_fast", handler: function(){
          Ext.MessageBox.prompt("Set Animation Speed","New speed in frames per second.",function(btn,text){
              if(btn == 'ok'){
                  if(parseFloat(text) < 1000 && parseFloat(text) > 0){
                    Ax.framerate = parseFloat(text);
                    wave2.set("m/framerate",Ax.framerate)
                    Ax.msg("Sucessfully set Animation speed", "The animation is now "+text+"fps")
                  }else{
                    Ax.msg("Animation Speed not in Range","The speed of the animation must be larger than zero and below 1000")
                  }
                }
            },null,null,Ax.framerate)
          }},{text: "Play", xtype: "cycle" , showText: true,
        items: [{iconCls: "tb_play",text: "Play"},{iconCls: "tb_pause",text: "Pause",checked:true}],
        changeHandler: function(){Ax.controls.toggle()}},
        {xtype: "tbfill"},
        {iconCls: "tb_plugin_conf", menu: [
  {text: "Script Executor", iconCls: "tb_script", handler: function(){Ax.macroExec()}},
  {text: "Publish (More)", iconCls: "tb_publish", menu: [
  {text: "OPF Array", iconCls: "tb_silverlight", handler: function(){Ax.ex.array.save()}},
  {text: "Processing", iconCls: "tb_processing", handler: function(){Ax.ex.processing.save()}},
	{text: "Silverlight", iconCls: "tb_silverlight", handler: function(){Ax.ex.silverlight.save()}},
	{text: "JavaFX", iconCls: "tb_javafx", handler: function(){Ax.ex.javafx.save()}}
  
        ]},
        {text: "Set Name", iconCls: "tb_info",handler: function(){
        Ax.setAnimationName(prompt("Enter New Animation Name (Not Synced and not used)",Ax.animation.name))
        }},
        {
      text: "Scripting Docs",
      iconCls: "tb_docs",
      handler: function(){
        Ax.loadAdvanced();
      }
    }
        ]}
        ],
        
			//bbar: new Ext.StatusBar(Ax.PreviewStatusbar),
			border: false,
			/*
      tools: [{id: "gear"},{id: "help",
			qtip: "Preview and Export your animations to Flash&reg; ... Hopefully"}],
      */
			iconCls: "preview_icon",			
            layout:"fit",
						 html:"<div class=\"x-border-layout-ct canvas_container\">"+
       "<div class=\"canvas\" id=\"previewcanvas\">Loading...</div>"+
       "</div>"
			
			}],
			listeners: {
      'render' : function(){
        setTimeout(function(){
              //Ax.setAnimationName(Ax.animation.name);
        },100);
        
      },
				'activate' : function(){
          
          if(!Ax.timeline.el){
            (function(){ //shit so much polling. event based would be better
            if(Ax.viewport){
            try {
                  Ax.initTimeline()
                  Ax.addLayer()
                  Ax.addFrames(99)
                  //Ax.toKeyframe(1, "Layer 1")
                  }catch(err){
                      Ext.MessageBox.alert("Timeline Initialization FAILED.",err.message)
                  }
            }else{
              setTimeout(arguments.callee, 100);
            }
          })()
          }
          
          (function(){
            if(Ax.viewport && Ax.layers['~1']){
              
              //Ax.gs(7);
              Ax.viewport.findById("tools").collapse()
              //Ax.viewport.findById("toolbar").getTopToolbar().items.item(5).menu.items.item(0).setText("Preview Mode")
              //Ax.init_preview();
              clearTimeout(Ax.preview_timeout);
              
              Ax.preview_mode = true;
              Ax.preview_increment();
            }else{
              setTimeout(arguments.callee, 100);
            }
            
          })()
          
          

        
				},
				'deactivate' : function(){
					Ax.controls.pause()
				}
			},
            layout:"fit",
			border: true
          }/*,{
		  iconCls: "animations_icon",
		  xtype: "animationbrowser", 
		  tabTip: "Share and View other user's animations",
		  listeners: {
				'activate' : function(){

					//Ax.gs(8)
				},
				'deactivate' : function(){
					Ax.player_pause()
				}
			}
		  }*/]
      }]
  })
   Ax.LayoutCenterPanel.superclass.initComponent.apply(this, arguments);
  }
  })
  
  Ext.reg("layoutcenter",Ax.LayoutCenterPanel)
  
  
  Ax.setAnimationName = function(name){
    if(!name || name.replace(/ /g,"") == ""){
      name = "Untitled Production"
    }
    Ax.animation.name = name;
    
    //if(Ax.viewport.findById("canvas").getTopToolbar().items){
    //    Ax.viewport.findById("canvas" ).getTopToolbar().items.item(1).getEl().value = name}
    //if(Ax.viewport.findById("preview").getTopToolbar().items){
    //    Ax.viewport.findById("preview").getTopToolbar().items.item(1).getEl().value = name}
  }



 /*JS File: ../js/ui/panels/west.js*/ 


 Ax.LayoutWestPanel = Ext.extend(Ext.Panel,{
initComponent: function(){
Ext.apply(this,{
    region:"west",
    //title:"Tools",
    id: "tools",
    split:true,
    collapsible:true,
    titleCollapse:true,
    hideCollapseTool: true,
    //html: "<img src='../img/mockup/tools.png'>",
    width:50,
    border:true,
    items: [{xtype:"toolbox"},{xtype: "drawpanel"}]
  })
   this.initialConfig.collapsible = true; //bugfix from http://outroot.com/extjs/bug1/ 
   Ax.LayoutWestPanel.superclass.initComponent.apply(this, arguments);
  }
  })
  
  Ext.reg("layoutwest",Ax.LayoutWestPanel)

  
  Ax.tools_setcollapse = function(item){
if(Ax.viewport.findById("tools").collapsed != item.checked){
Ax.viewport.findById("tools").toggleCollapse();
}
}



 /*JS File: ../js/ui/panels/north.js*/ 


 Ax.LayoutNorthPanel = Ext.extend(Ext.Panel,{
initComponent: function(){

Ext.apply(this,{
    region:"south",
	layout: "fit",
    collapsible:true,
    collapseMode: "mini",
    split:true,
	border: false,
  id: "timeline",
    height:60,
//    border:true,
	items: {xtype: "timeline", border: false}
  })
  this.initialConfig.collapsible = true; //bugfix from http://outroot.com/extjs/bug1/ 

   Ax.LayoutNorthPanel.superclass.initComponent.apply(this, arguments);
  }
  })
  
  Ext.reg("layoutnorth",Ax.LayoutNorthPanel)



 /*JS File: ../js/ui/main.js*/ 


 /*
 Main User Interface
 'Glues' all components together
 */
Ext.onReady(function(){

    Ax.viewport = new Ext.Viewport({
        layout: "border",
        border: false,
        window: {
            layout: "fit"//,
            //tbar: {xtype: "maintoolbar"}
        },
        
        
        items: [/*{
            region: "north",
            id: "toolbar",
            border: false,
            tbar: Ax.MainToolbar,
            height: 27
        }, */{
            region: "center",
            layout: "border",
            border: false,
            items: [{
                xtype: "layoutcenter"
            }, {
                xtype: "layoutnorth"
            //}, {
            //    xtype: "layoutsouth"
            }, {
                
                xtype: "layoutwest",
                collapseMode: "mini"
            }/*, {
                xtype: "layouteast"
            }*/] //end main app border layout items
        }]
    
        //}]  //end main toolbar border layout items
    } //end border layout
); //End Viewport
}); //End Ext.onReady



 /*JS File: ../js/animation/tween_core.js*/ 


 /**
 * @author antimatter15
 */

Ax.largest_nonempty = function(frame,layer,object){
  //searches for largest non-empty frame that is less than the frame
  var nonempty = [];
  object = (object)?object:Ax.layers;

  for(var i = 0; i < object[layer].keyframes.length; i++){
    if(parseInt(object[layer].keyframes[i]) < frame){
        nonempty.push(parseInt(object[layer].keyframes[i]))
    }
  }
  return nonempty.sort(function(a,b){return b - a})[0];//sort descending and pull the first result (largest)
}

Ax.smallest_nonempty = function(frame,layer,object){
  //i'm just gonna copy from largest_nonempty and be too lazy to change the comments
  //so... yeah.... crappy documentation...
    //searches for largest non-empty frame that is less than the frame
  var nonempty = [];
  object = (object)?object:Ax.layers;

  for(var i = 0; i < object[layer].keyframes.length; i++){
    if(parseInt(object[layer].keyframes[i]) > frame){
        nonempty.push(parseInt(object[layer].keyframes[i]))
    }
  }
  return nonempty.sort(function(a,b){return a - b})[0];//sort descending and pull the first result (largest)
}

Ax.count_frames = function(layers, startAt){
	startAt = (startAt)?startAt:0; //set starting point
	layers = (layers)?layers:Ax.layers; //set layers object
	
	for (var layer in layers) { //loop through layers
	    //calculate the biggest frame
		var layer_frames = layers[layer].keyframes.sort(function(a, b){
            return b - a; //sort the keyframe from largest to smallest and pull out the biggest number
        })[0]; //the largest
		
        if (layer_frames > startAt) { //if this is bigger than current value
            startAt = layer_frames; //set current value
        }//end if
	}//end loop
	return startAt; //return last known frame
}

/*Alternate Tweening Engine. Theoretically Vastly Superior*/
Ax.getSFTween_core = function(frame, frame1, frame2, layer, store, clonefunc){//get single frame tween
    var frame1_data = {}, //where all the organized data goes
 		frame2_data = {}, //read above
 		frames_comp = {}, //an array of stuffs 
 		tween_frame = {}, //the tweens stuffs
		tween_axout = [] //definately just sex (xkcd reference)
  
  if(!store[frame1]){
    return Ext.ux.clone(store[frame2]);
  }
  
	for(var i = 0; i < store[frame1].length; i++){ //loopy
		frame1_data[store[frame1][i].id] = store[frame1][i];
		frames_comp[store[frame1][i].id] = null
	}
	for(var i = 0; i < store[frame2].length; i++){
		frame2_data[store[frame2][i].id] = store[frame2][i];
		frames_comp[store[frame2][i].id] = null
	}
	
	tween_frame = Ext.ux.clone(frame2_data)
	
	for(var i in frames_comp){
		if (frame2_data[i] && frame1_data[i]) {
			for (var a in frame2_data[i]) {
				tween_frame[i][a] = Ax.tweenAttribute(a, frame1, frame2,  frame1_data[i][a],  frame2_data[i][a], frame)
			}
		}
		
	}
	
	for(var i in tween_frame){
		tween_axout.push(tween_frame[i])
	}

    
  return tween_axout;
}


/*
 TWEENING FUNCTION
 *****************
 Now:
 Width,Height, Line Width, x, y
 Future:
 DONE - rotation transform, find out the rotation value, run them through the magickal Ax.tweenNumber function
 DONE - color tween: split hex string into 3 segments, turn that into a number, run it throught he magical function and re-hexify
 
 DONE - Stuff that isn't possible through the current toolset, but should work automagically:
 DONE - opacity tweening (i think they're stored in numbers)
 Fun:
 I donno, maybe some text tweening (i dont have any idea how that'd work. maybe changing a character every frame or something.
 */

Ax.tweenAttribute = function(name, frame1, frame2, value1, value2, index){
	if (value1 == value2){//if they are the same, why bother?
		return value1;
	}
  if(typeof value1 == "undefined" || typeof value2 == "undefined"){
    //Ax.toastMsg("Tweening Error","Value is Undefined")
    
    return value2; 
    
  }
    if (typeof value2 == "number") { //currently only numbers are tweenable
        return Ax.tweenNumber(frame1, frame2, value1, value2, index);
    }
    if (name == "path") {
        return Ax.tweenPath(frame1, frame2, value1, value2, index);
    }
	if (value1.toString().substr(0,1) == "#" && value2.toString().substr(0,1) == "#"){ //color tweening
		return Ax.tweenHex(frame1, frame2, value1, value2, index);
	}

    return value2; //return the second if no tweening possible.
}



Ax.tweenPath = function(frame1, frame2, value1, value2, index){
    
    var path1 = Ax.parsePath(value1);
    var path2 = Ax.parsePath(value2);
    var newpath = Ext.ux.clone(path2)
    /*
    for (var i = 0; i < value2.length; i++) {
        if (parseFloat(value2[i]).toString() == value2[i]) {
            value2[i] = Ax.tweenNumber(frame1, frame2, parseFloat(value1[i]), parseFloat(value2[i]), index);
        }
    }
    */
    
    for(var i = 0; i < path2.length; i++){
      if(newpath[i][0] != "Z"){
        newpath[i][1] = Ax.tweenNumber(frame1, frame2, path1[i][1], path2[i][1], index);
        newpath[i][2] = Ax.tweenNumber(frame1, frame2, path1[i][2], path2[i][2], index);
      }
    }
    
    return newpath
}

Ax.parsePath = function(points){
    if(typeof points == "string"){
      return Raphael.parsePathString(points)
    }else{
      return points//Ext.ux.clone(points);
    }
}

Ax.tweenHex = function(frame1, frame2, value1, value2, index){
	value1=Ax.hex2rgb(value1);
	value2=Ax.hex2rgb(value2);

	return "#"+[Ax.toHex(Ax.tweenNumber(frame1, frame2, parseInt(value1.R), parseInt(value2.R), index)),
		Ax.toHex(Ax.tweenNumber(frame1, frame2, parseInt(value1.G), parseInt(value2.G), index)),
		Ax.toHex(Ax.tweenNumber(frame1, frame2, parseInt(value1.B), parseInt(value2.B), index))].join("");
}

Ax.hex2rgb = function(hex){
	var match = hex.toLowerCase().match(/^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/);
	if (match){
		return {R:parseInt(match[1], 16), G:parseInt(match[2], 16), B:parseInt(match[3], 16)};
	}else{
		return {R: 0, G: 0, B: 0};
	}
}

Ax.toHex = function(color){
	color=parseInt(Math.floor(color)).toString(16);
	return (color.length<2)?"0"+color:color;
}

Ax.tweenNumber = function(frame1, frame2, value1, value2, index){//frame1, frame2, first number, second number, index (from first)
    //no type checking yet, cause i dont feel like it
    var raw = ((index - frame1) / (frame2 - frame1));
    var smoothed = 1-(Math.cos(Math.PI*raw)+1)/2;
    return value1 + smoothed * (value2 - value1); //just hope this works!
    //blah!
}//he he!!!!!!!!!!!!!!!!!!!!!! mua ha ah ha ha



 /*JS File: ../js/animation/tween.js*/ 


 /*tweening functionality*/

Ax.tween = function(frame1,frame2,layer){//this function loops through frames inbetween and flags them as tweens
//unlike the prior versions that actually computed the frames here, everything is just flagged. So,  the speed differences are enourmous.
//sadly, those tweens have to be computed eventually, so it has to be calculated all when you are about to preview things. There used to be
//a cool little cache-script that would cache things and hopefully reduce the processing load when previewing, but that didn't work well
//as i was too  lazy to add one single likne to this function to make it automatically clear 
  //console.log(frame1,frame2,layer)
  if(frame1 && frame2){
    //*ZOMG! CONZONLE DAWT LOOG!!!*/console.log(frame1,frame2,layer);
    for(var i = frame1 + 1; i < frame2; i++){//loop through frames from frame1 to frame2
      Ax.toTween(i,layer);//huh? oh. tell the timelinezo
    }//end loop
  }//end if tingy
}//end functioney

Ax.getSFTween = function (frame, frame1, frame2, layer, store){//get single frame tween
  if(!frame){frame = Ax.tcurrent.frame}//pull defaults if none
  if(!layer){layer = Ax.tcurrent.layer}//same as above,but i'll repeat it so i get a higher comment-ratio: pull defaults if none
  if(!frame1){frame1 = Ax.largest_nonempty(frame,layer)};//pull the last keyframe if none
  if(!frame2){frame2 = Ax.smallest_nonempty(frame,layer)};//pull the next keyframe if none, which is essentially the same thing as the one before
  //but i feel like increasing my comment ratio (as in the if(!layer){... line) but i'm repeating it for a higher comment-code-ratio (as in that same line). 
  
  //console.log(frame, frame1,frame2,layer)
  //tween a single frame and get a single frame (framedump) in return
  //store = (store)?store:Ax.canvas_storage[layer];
  //store = (store)?store:Ax.canvas_storage[layer];
  
  if(!store){
    store = {}
    store[frame1] = Ax.getcanvas(frame1, layer);
    store[frame2] = Ax.getcanvas(frame2, layer);
  }
  
  
  if(!store[frame1]){
  	Ax.toastMsg("Error!","Ajax Animator's Tweening Engine has encountered a potentially critical error because store[frame1 ("+frame1+")] is non-existant. ")
  	//store[frame1] = [];
  }
  if(!store[frame2]){
  	Ax.toastMsg("Error!","Ajax Animator's Tweening Engine has encountered a potentially critical error because store[frame2 ("+frame2+")] is non-existant.")
  	//store[frame2] = [];
  }
  
 /*some random benchmarking stuffs, evidently, the engines are roughly the same in speed
 var first = (new Date()).getTime();
  Ax.getSFTween_old_core(frame, frame1, frame2, layer, store);
  first = ((new Date()).getTime() - first)
  var second = (new Date()).getTime();
  Ax.getSFTween_core(frame, frame1, frame2, layer, store);
  second = ((new Date()).getTime() - second )
  
  console.log(first,second)
*/
  
  
  	return Ax.getSFTween_core(frame, frame1, frame2, layer, store);
  
}




 /*JS File: ../js/animation/controls.js*/ 


 Ax.controls = {
    play: function(){
        Ax.viewport.findById("maintabpanel").activate(1)
        Ax.preview_increment();
    },
    toggle: function(){
      if(Ax.preview_timeout)
        Ax.controls.pause()
      else
        Ax.controls.play();
    },
    pause: function(){
        Ax.viewport.findById("maintabpanel").activate(1)
        clearTimeout(Ax.preview_timeout);
        clearTimeout(Ax.preview_timeout);
        clearTimeout(Ax.preview_timeout);
        Ax.preview_timeout = null;
    },
    next: function(){
        switch (Ax.viewport.findById("maintabpanel").getActiveTab().getId()) {
            case "canvas_tab":
                Ax.selectFrame(Ax.tcurrent.frame + 1, Ax.tcurrent.layer)
                break;
            case "preview_tab":
                Ax.preview_frame++;
                break;
        }
    },
    previous: function(){
        switch (Ax.viewport.findById("maintabpanel").getActiveTab().getId()) {
            case "canvas_tab":
                Ax.selectFrame(Ax.tcurrent.frame - 1, Ax.tcurrent.layer)
                break;
            case "preview_tab":
                Ax.preview_frame--;
                break;
        }
    },
    last: function(){
        //Ax.msg("No worky", "this doesn't work yet.")
        switch (Ax.viewport.findById("maintabpanel").getActiveTab().getId()) {
            case "canvas_tab":
                Ax.selectFrame(Ax.count_frames(), Ax.tcurrent.layer);
                break;
            case "preview_tab":
                Ax.preview_frame = Ax.count_frames();
                break;
        }
	},
    first: function(){
        switch (Ax.viewport.findById("maintabpanel").getActiveTab().getId()) {
            case "canvas_tab":
                Ax.selectFrame(1, Ax.tcurrent.layer);
                break;
            case "preview_tab":
                Ax.preview_frame = 1;
                break;
        }
    }
}



 /*JS File: ../js/animation/frames.js*/ 


 
Ax.dumpframe = function(frame,layer){
  //console.info(layer)
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}
  
  //console.log(layer)
  //console.log(frame,layer)
  //dumps current frame onto the frame_storage
  //oops. scratch that, it's now the *canvas*_storage (without asterekasdwz)
  
  //if(!Ax.canvas_storage[layer]){
  //  Ax.canvas_storage[layer] = {};
    //console.log("CLOGBLANK")
  //}
  
  //Ax.canvas.unselect();
  var shapedump =  Ax.dumpshapes();
  //console.log(shapedump)
  if(!Ax.isTween(frame,layer)){
    //Ax.canvas_storage[layer][frame] = shapedump;
    Ax.setcanvas(frame, layer, shapedump)
  }
  return shapedump;

}


Ax.dumpframe2 = function(frame, layer){
  if(!frame)frame=Ax.tcurrent.frame;
  if(!layer)layer=Ax.tcurrent.layer;
  
  if(frame == Ax.tcurrent.frame && layer == Ax.tcurrent.layer){
    var shapedump = Ax.dumpshapes()
    Ax.setcanvas(frame, layer, shapedump)
  
  }else{
  //  var shapedump = Ax.getshapes(frame, layer);
  }
  //Ax.setcanvas(frame, layer, shapedump)
  
}

Ax.loadframe = function(frame, layer){
  if(!frame)frame=Ax.tcurrent.frame;
  if(!layer)layer=Ax.tcurrent.layer;
  
  console.log("Ax.loadframe: frame ", frame, " layer ", layer);
  
  //Ax.toastMsg('load',frame+layer)
  var tolisten = []
  
  Ax.deleteAll();
  Ax.loadonion(frame, layer);
  
  for(var i in Ax.layers){
    var needlisten = [];
    if(i == layer){
      needlisten = Ax.loadframe_core(frame, i)
      if(Ax.layers[i].visible != true){
        Ax.msg("Layer Visibility","Please note that the current layer will always show regardless of visibility settings.")
      }
    }else if(Ax.layers[i].visible == true){
      needlisten = Ax.loadframe_core(frame, i, true)
    }
    for(var c = 0; c < needlisten.length; c++){
      tolisten.push(["c",i,needlisten[c]])
    }
  }
  
  Ax.autodiff();
  Ax.relisten(tolisten)
}

Ax.onion_skinning = 0.2;

Ax.loadonion = function(frame, layer){
  if(frame > 1 && Ax.onion_skinning){
    var shapes = Ax.getcanvas(Ax.largest_nonempty(frame,layer),layer);
	  for (var i = 0; i < shapes.length; i++) {
		  Ax.loadShape(shapes[i], true).attr("opacity",parseFloat(Ax.onion_skinning));
	  }
	  
	}
}

Ax.loadframe_core = function(frame,layer, noattachlistener){
  //console.log(Ax.canvas_storage[layer][frame])
  
  if(Ax.isKeyframe(frame, layer)){
    
  //Ax.msg("LOAD","KF")
    Ax.canvas.unselect();
    //Ax.canvas.renderer.removeAll();
    //console.log("Load KF")
    Ax.loadShapes(Ax.getcanvas(frame, layer), noattachlistener)
    //Ax.autodiff();
    return [frame];
  }else if(Ax.isTween(frame,layer)){
    
  //Ax.msg("LOAD","TN")
    Ax.canvas.unselect();//unselect
    //console.log("Load TN")
    //Ax.canvas.renderer.removeAll();//remove all objects
    Ax.loadShapes(Ax.getSFTween(frame,Ax.largest_nonempty(frame,layer),Ax.smallest_nonempty(frame,layer),layer), noattachlistener);//load tween
    return [Ax.largest_nonempty(frame,layer),Ax.smallest_nonempty(frame,layer)];//finish
  }
  //Ax.canvas.renderer.removeAll();//remove all objects
  //console.log("Load LF")
  
  //Ax.msg("LOAD","LF")
  
  Ax.loadShapes(Ax.getcanvas(Ax.largest_nonempty(frame,layer),layer), noattachlistener);//load last keyframe
  //note to self: rename function to make more sense.....
  Ax.canvas.unselect();
  //Ax.canvas.renderer.removeAll();
  return [Ax.largest_nonempty(frame,layer)];
}




 /*JS File: ../js/animation/diff.js*/ 


 //This is a file that is virtually the core of the tweening engine
//not really. it just detects what frames are keyframes. automatically.

Ax.diff_exclude = ["id","translation","subtype"]

Ax.autodiff = function(){
    //save canvas state
    //console.log(Ax.tcurrent)
    if (Ax.tcurrent.layer && Ax.tcurrent.frame) { //..only if the current frame *exists*
        //here is the magical code that does the history revision saving stuffs

        if (Ax.iscanvas() &&
          Ax.diff_core(Ax.dumpshapes(), Ax.getcanvas()) != true) {
            //console.log("iscanvas")
            Ax.dumpframe2(); //dump current canvas to current layer
        }
        
        
        //check for diff
        
        if (Ax.isTween() == true && Ax.diff_core(Ax.dumpshapes(), Ax.getSFTween()) != true) {
            //Ax.msg("Sorry!","For some reason, this feature isn't working at all. So, no editing tweens yet. Pity.")
            //console.log("specialtotweenness")
            Ax.toKeyframe(Ax.tcurrent.frame, Ax.tcurrent.layer)
            Ax.dumpframe2(); //dump current canvas to current layer
        }
        else if (
            Ax.diff_core(Ax.getcanvas(Ax.largest_nonempty(Ax.tcurrent.frame, Ax.tcurrent.layer), Ax.tcurrent.layer), Ax.dumpshapes()) != true &&
            !Ax.isTween()) {
                Ax.toKeyframe(Ax.tcurrent.frame, Ax.tcurrent.layer);
                Ax.dumpframe2(); //dump current canvas to current layer
            }
            else 
                if (Ax.isKeyframe() == false) {
                    //Ax.toBlank_core(Ax.tcurrent.frame,Ax.tcurrent.layer)
                    
                    //delete Ax.canvas_storage[Ax.tcurrent.layer][Ax.tcurrent.frame];
                    //Ax.deletecanvas(Ax.tcurrent.frame,Ax.tcurrent.layer)
                }
    }
}

Ax.diff = function(frame1, frame2, layer){
    //takes two frame identifier numbers and a layer as arguments
    //returns true or false, true being identical, false being different
    return Ax.diff_core(Ax.getcanvas(frame1, layer), Ax.getcanvas(frame2, layer))
}



Ax.diff_core = function(shapedump1, shapedump2){
    //It takes two arguments, one with the shape dump of the first frame
    // ( you can find it in the canvas_storage object, or dump it fresh)
    //with the dumpshapes() function. The ShapeDump takes the from of a
    //array with json shape dumps inside.
    //console.log(shapedump1, shapedump2)
    if ((!shapedump1 || !shapedump2) || (shapedump1.length != shapedump2.length)) {
        //alert(shapedump1.length + ":" + shapedump2.length)
        return false;
    }
    else {
        for (var i = 0; i < shapedump1.length; i++) {
            for (var x in shapedump2[i]) {
                //console.log(i,shapedump1[i].type,x,shapedump2[i][x],shapedump1[i][x])
                if (Ax.diff_attr(shapedump1[i][x], shapedump2[i][x], x) == false) {
                    //console.log(shapedump1[i][x], shapedump2[i][x], x)
                    
                    return false;
                }
            }
        }
    }
    return true;
}

Ax.diff_list = function(shapedump1, shapedump2){
	var difflist = [];
    if ((!shapedump1 || !shapedump2) || (shapedump1.length != shapedump2.length)) {
        return false;
    }
    else {
        for (var i = 0; i < shapedump1.length; i++) {
            for (var x in shapedump2[i]) {
                if (Ax.diff_attr(shapedump1[i][x], shapedump2[i][x], x) == false) {
                    difflist.push([shapedump1[i], x])
                }
            }
        }
    }
    return difflist;
}


Ax.diff_attr = function(value1, value2, attrid){
    if (Ax.diff_exclude.indexOf(attrid) == -1 && value1 !== null && value2 !== null && value1 !== undefined && value2 !== undefined) {
        if (typeof value2 == "number") {
            value2 = Math.round(value2 * 100) / 100
            value1 = Math.round(value1 * 100) / 100
        }
        if (attrid == "transform") {
            if (Math.round(Ax.parseTransform(value2)[0]) != Math.round(Ax.parseTransform(value1)[0])) {
                return false
            }
        }else if(attrid == "path"){
          value1 = Ax.parsePath(value1);
          value2 = Ax.parsePath(value2);
          if(value1.length != value2.length){
            return false
          }
          for(var i = 0; i < value2.length; i++){
            if(value2[i][0] == "M" || value2[i][0] == "L"){
              if(value2[i][1].toFixed(3) != value1[i][1].toFixed(3) || 
                value2[i][2].toFixed(3) != value1[i][2].toFixed(3)){
                return false
              }
            }
          }
          return true
        }
        else {
            if (value2 != value1) {
                //console.log(attrid, value1, value2)
                //Ax.msg(attrid, value1 + ":" + value2)
                return false;//not same
            }
        }
    }else{
      //n/a
    }
    
    return true;
}





 /*JS File: ../js/animation/animations.js*/ 

/* bntr

 //this file is soooooo fubared
//omg.....

Ax.AnimationBrowser = Ext.extend(Ext.Panel, {
    initComponent: function(){
        Ext.apply(this, {
            id: "Animations",
            xtype: "panel",
            title: "Animations",
            border: false,
            layout: "fit",
            items: {
                layout: "border",
                border: false,
                items: [{
                
                    //border: false,
                    region: "center",
                    
                    title: "Player",
                    id: "Player",
                    layout: "border",
                    items: [{
                        region: "north",
                        border: false,
                        tbar: [{
                            text: "By:&nbsp;Unavailable"
                        }, {
                            xtype: "tbfill"
                        }, "Unavailable"],
                        height: 27
                    }, {
                        region: "south",
                        border: false,
                        bbar: [{
                            text: "Play",
                            iconCls: "play_icon",
                            handler: function(){
                                Ax.player_play()
                            }
                        }, {
                            text: "Pause",
                            iconCls: "stop_icon",
                            handler: function(){
                                Ax.player_pause()
                            }
                        }, {
                            text: "Import to Editor",
                            iconCls: "import_icon",
                            handler: function(){
                                Ax.player_import()
                            }
                        }, {
                            xtype: "tbfill"
                        }, "?/? ?FPS"],
                        height: 27
                    }, {
                        region: "center",
                        border: false,
                        html: "<div class=\"x-border-layout-ct canvas_container\"><div id=\"playercanvas\" class=\"canvas\"></div></div>"
                    }],
                    autoScroll: true,
                    tools: [{
                        id: "gear"
                    }, {
                        id: "help",
                        qtip: "View and share animations with other users. Use the left panel to browse for animations," +
                        " and click them to view them. Feel free to press the \"import\" button and make improvements."
                    }],
                    iconCls: "player_icon"
                }, {
                    //border: false,
                    region: "west",
                    id: "treebrowse",
                    title: "Browse",
                    collapseFirst: false,
                    tools: [{
                        id: "plus",
                        qtip: "Expand All",
                        handler: function(){
                            Ax.viewport.findById("treebrowse").expandAll()
                        }
                    }, {
                        id: "minus",
                        qtip: "Collapse All",
                        handler: function(){
                            Ax.viewport.findById("treebrowse").collapseAll()
                        }
                    }],
                    iconCls: "browse_icon",
                    width: 200,
                    split: true,
                    collapsible: true,
                    layout: "fit",
                    titleCollapse: true,
                    
                    //items: [{
                    //border: false,
                    xtype: "treepanel",
                    useArrows: true,
                    autoScroll: true,
                    animate: true,
                    enableDD: false,
                    containerScroll: true,
                    bbar: [{
                        text: "Reload",
                        qtip: "Reload Tree Data",
                        iconCls: "reload_icon",
                        handler: function(){
                            Ax.viewport.findById("treebrowse").getLoader().load(Ax.viewport.findById("treebrowse").getRootNode())
                        }
                    }],
                    root: new Ext.tree.AsyncTreeNode({
                        text: 'Animations',
                        expanded: true,
                        draggable: false,
                        id: '.'
                    }),
                    loader: new Ext.tree.TreeLoader({
                        dataUrl: (window.location.protocol=="file:")?null:Ax.files.userlist
                    }),
                    listeners: {
                        "click": function(node){
                            if (node.childrenRendered == false) {
                                Ax.ajax({
                                    url: Ax.files.animations + node.id,
                                    success: function(e){
                                        Ax.player_pause()
                                        Ax.init_player(e.responseText);
                                        Ax.player_play()
                                    }
                                })
                            }
                        }
                    }
                
                
                
                    //}]
                
                }]
            }
        })//end ext.apply
        Ax.AnimationBrowser.superclass.initComponent.apply(this, arguments);
    }
    
})

Ext.reg("animationbrowser", Ax.AnimationBrowser)

Ax.showanimationbrowser = function(){
    Ax.viewport.findById("maintabpanel").activate(2)
}

*/



 /*JS File: ../js/animation/storage.js*/ 


 Ax.canvas_storage = {}; //Initial data.

Ax.iscanvas = function(frame, layer){
  //getcanvas but without actually givint results, just boolean
  if(!frame)frame=Ax.tcurrent.frame;
  if(!layer)layer=Ax.tcurrent.layer;
  
  return !!wave2.subkeys("c/"+layer+"/"+frame+"/").length;
}

Ax.getcanvas = function(frame, layer){
  if(!frame)frame=Ax.tcurrent.frame;
  if(!layer)layer=Ax.tcurrent.layer;
  
  var prefix = "c/"+layer+"/"+frame+"/";
  var keys = wave2.subkeys(prefix)
  var shapes = []
  for(var i = 0; i < keys.length; i++){
    shapes.push(Ax.decompress_attr(wave2.getJ(prefix+keys[i])))
  }
  //if(shapes.length > 0){
    return shapes
  //}
  //return [];
}

Ax.setcanvas = function(frame, layer, shapes){
  for(var i = 0; i < shapes.length; i++){
    var compressed = Ax.compress_attr(shapes[i]);
    wave2.set(["c", layer, frame, compressed.id], Ax.small_json(compressed))
    
  }
}

Ax.deletecanvas = function(frame, layer){
  //do nothing
  if(Ax.iscanvas(frame, layer)) wave2.del_subkeys("c/"+layer+"/"+frame+"/");
}


Ax.getlayercanvas = function(layer){
  if(!layer)layer=Ax.tcurrent.layer;
  
  var prefix = "c/"+layer+"/";
  var keys = wave2.subkeys(prefix)
  var layer = {}
  for(var i = 0; i < keys.length; i++){
    var key = keys[i].split("/");
    if(!layer[key[0]]){
      layer[key[0]] = [] //t3h framename
    }
    
    layer[key[0]].push(wave2.getJ(prefix+keys[i]))
  }
  return layer;
}

Ax.removeallcanvas = function(){
   wave2.del_subkeys("c/")
}

Ax.setlayercanvas = function(layer, data){
  for(var frame in data){
    Ax.setcanvas(frame, layer, data[frame]);
  }
}
Ax.getshapes = function(frame,layer){
  //alert("alerts are good; look at storage.js")
	//a very high-level function ish
	if(!frame){frame = Ax.tcurrent.frame;}
	if(!layer){layer = Ax.tcurrent.layer}
	
	//if(!Ax.getcanv){
		//conzoledawtloog("Error: NO LAYER OBJECT", Ax.canvas_storage[layer], Ax.canvas_storage, layer)
	//	return [];
	//}
	if(Ax.isKeyframe(frame, layer)){
		//console.log("OUT: KEYFRAME")
		return Ax.getcanvas(frame,layer);
	}else if(Ax.smallest_nonempty(frame, layer) && Ax.largest_nonempty(frame, layer)){
		//console.log("OUT: TWEEN")
		return Ax.getSFTween(frame, Ax.largest_nonempty(frame, layer), Ax.smallest_nonempty(frame, layer), layer)
	}
	
	//conzoledawtloog("Error: BLANK FRMAE")
	//return [];
  return Ax.getcanvas(Ax.largest_nonempty(frame,layer),layer)
    
}



 /*JS File: ../js/animation/timeline.js*/ 


 Ax.Timeline = Ext.extend(Ext.Panel, {
    initComponent: function(){
        Ext.apply(this, {
            layout: "border",
            items: [{
                region: "center",
                autoScroll: true,
                border: false,
                html: "<div id='timeline_core' class='x-unselectable' style='height: 100%; width: 100%'>Loading Frames...</div>"
            }, {
                region: "west",
                width: 150,
                border: false,
                split: true,
                
                collapsible: true,
                collapseMode: "mini",
                autoScroll: true,
                layout: "fit",
                //html: "Layers"
                items: {
                    id: "layers",
                    xtype: "editorgrid",
                    border: false,
                    hideHeaders: true,
                    plugins: [new Ext.ux.grid.CellActions({
                        callbacks: {
                            "tb_delete": function(grid, record, action, value){
                                if (Ax.tcurrent.layer == value) {
                                  return Ax.toastMsg("Error!","You can't delete the current selected layer!")
                                }
                                Ext.MessageBox.confirm("Delete " + value + "?", "Are you sure you want to delete " + value + "?", function(result){
                                    if (result == "yes") {
                                        Ax.deleteLayer(value)
                                    }
                                })
                            },
                            'tb_visible': function(grid, record, action, value){
                                
                                console.log(record);
                                console.log(action);
                                console.log(value);
                                
                              //you might be able to tell that this is a hack
                              var c = 0;
                              for(var i in Ax.layers){
                                //if(i == value){
                                if (Ax.layers[i].record == record) {
                                  break;
                                }
                                if(Ax.layers[i].visible){
                                  c++; //i dont know c++!
                                }
                              }
                              
                              Ax.layers[i].visible = false;
                              if(c >= Ext.query(".tb_visible").length){
                                c = 0
                              }
                                Ext.get(Ext.query(".tb_visible")[c]).addClass("tb_invisible");
                                Ext.get(Ext.query(".tb_visible")[c]).removeClass("tb_visible");
                                Ax.loadframe(Ax.tcurrent.frame,Ax.tcurrent.layer);

                              
                            },
                            'tb_invisible': function(grid, record, action, value){
                              var c = 0;
                              for(var i in Ax.layers){
                                //if(i == value){
                                if (Ax.layers[i].record == record) {
                                  break;
                                }
                                
                                if(!Ax.layers[i].visible){
                                  c++; //i dont know c++!
                                }
                              }
                              if(c >= Ext.query(".tb_invisible").length){
                                c = 0
                              }
                              Ax.layers[i].visible = true;
                              Ext.get(Ext.query(".tb_invisible")[c]).addClass("tb_visible");
                              Ext.get(Ext.query(".tb_invisible")[c]).removeClass("tb_invisible");
                              Ax.loadframe(Ax.tcurrent.frame,Ax.tcurrent.layer);
                            },
                            'tb_up': function(grid, record, action, value){
                                Ax.toastMsg("Error!","Not Implemented")
                            },
                            'tb_down': function(grid, record, action, value){
                              Ax.toastMsg("Error!","Not Implemented")
                            }
                        }
                    })],
                    viewConfig: {
                        autoFill: true,
                        forceFit: true
                    },
                    listeners: {
                        "afteredit": function(object){
                            //console.log(object.originalValue,object.value)
                            Ax.msg("Disabled","Renaming layers has been disabled for sync latency issues.")
                            //if(confirm("This will probably break the animation do to various sync latency issues. Are you sure you want to risk it?")){
                            //  Ax.renameLayer(object.originalValue, object.value)
                            //}
                            
                        }
                    },
                    sm: new Ext.grid.RowSelectionModel({
                        singleSelect: true
                    }),
                    
                    //clicksToEdit:1,
                    ds:/*BEGIN*/ new Ext.data.Store()/*END*/,
                    columns: [{
                        header: "Comment",
                        dataIndex: "comment",
                        editor: new Ext.form.TextField(),
                        cellActions: [{
                            iconCls: "tb_delete",
                            qtip: "Delete this layer."
                        },{
                            iconCls: "tb_visible",
                            qtip: "Toggle layer visiblity."
                        },{
                          iconCls: "tb_up",
                          qtip: "Shift Layer Up"
                        },{
                          iconCls: "tb_down",
                          qtip: "Shift layer Down"
                        }]
                    }]
                }
            }]
        })
        Ax.Timeline.superclass.initComponent.apply(this, arguments);
    }
})

Ext.reg("timeline", Ax.Timeline)


Ax.timeline_setcollapse = function(item){
if(Ax.viewport.findById("timeline").collapsed != item.checked){
Ax.viewport.findById("timeline").toggleCollapse();
}
}



 /*JS File: ../js/animation/timeline_core.js*/ 


 Ax.timeline = {el: null, mask: null};
Ax.layers = {}; //this stores all the data for layer stuff

Ax.preview_mode = false;

if(window.wave){
  Ax.preview_mode = true;
}

Ax.tstat = { //statistics for the count of frames and layers (displayed in timeline, not animation)
  layers: 0, //layers
  frames: 0  //frames.
}

Ax.tcurrent = { //currently selected frame/layer
  layer: "~1", //btw layers are strings (their ID)
  frame: 1 //im trying to decide whether this shoudl be 0 or null
}

Ax.renameLayer = function(oldname,newname){ //pretty neat. eh?
  Ax.layers[newname]=Ax.layers[oldname]; //we didn't have cusom layer names in the old version
  delete Ax.layers[oldname]; //...just random numbers
  
  Ax.canvas_storage[newname] = Ax.canvas_storage[oldname]; //but this seems nicer
  delete Ax.canvas_storage[oldname]; //right?
  
  return Ax.layers; //ok.
}



Ax.deleteLayer = function(name){//Sorta works.... anyone wanna test?
  if(Ax.tcurrent.layer == name){
  	return Ax.toastMsg("Delete Error","You can not delect the current selected layer.")
  }

  Ext.get(Ax.layers[name].el).remove(); //remove the table element
  Ax.viewport.findById("layers").getStore().remove(Ax.layers[name].record);
  //remoe the stuff from the little editable grid witht he titles
   
  delete Ax.layers[name]; //delete the entry
  Ax.tstat.layers--; //we removed a frame...
  
  wave2.del_subkeys("c/"+name+"/")
  wave2.del_expkeys(new RegExp("k\/.*\/"+RegExp.escape(name))) //ugh nasty
  //wave2.del_subkeys("k/"+name+"/")
}

Ax.addLayer = function(layername){
  layername = "~"+(Ax.tstat.layers+1).toString()//(layername)?layername:"~"+((Ax.tstat.layers+1).toString());

  var f_layer = document.createElement("tr"); 
  Ax.layers[layername] = {
    el:f_layer,
    keyframes: [1],
    visible: true,
    //tweens: [],
    record: new Ext.data.Record({comment:"Layer "+(Ax.tstat.layers+1).toString()})//layername})
    }
  Ax.viewport.findById("layers").getStore().add(Ax.layers[layername].record)
  
  if(!Ax.canvas_storage[layername]){
    Ax.canvas_storage[layername] = {"1":[]};//create a canvas storage slot with first frame set to blank
  }
  
  //Ext.log(f_layer.innerHTML)
  //Ax.current.layer = layer
  Ax.tstat.layers++
  Ax.timeline.el.appendChild(f_layer)
  
  for(var frame = 0; frame < Ax.tstat.frames; frame++){
    Ax.addFrame_core(frame+1,layername)
  }
  setTimeout(function(){
    if(Ax.getFrame(1, layername)){
    //Ax.toKeyframe(1,layername)
    //console.log(Ax.getFrame(1, layername).getY())
      Ax.selectFrame(1, layername)
    }
  },10)
  //Ext.log(f_layer.innerHTML)
  
  Ax.toKeyframe(1, layername)
  
  return f_layer;
}

Ax.addFrame = function(){
  Ax.tstat.frames++
  for(var layer in Ax.layers){
    Ax.addFrame_core(Ax.tstat.frames,layer)
  }
}

Ax.addFrames = function(frames){ //mind the s, this just loops through whatever number and makes so many frames
  for(var i = 0; i < frames; i++){
    Ax.addFrame()
  }
}




Ax.addFrame_core = function(frame,layer){
  //console.log(layer)
  var frame_cell = document.createElement("td")
  //frame.style.bgColor = "#99BBE8";
  frame_cell.className = "frame"

  var frame_content = document.createElement("div")
  frame_content.className = "frame"
  frame_content.innerHTML =  frame //[1,2,5,10,42,420,316,4242,1337][Math.floor(Math.random()*9)];

  switch(frame_content.innerHTML.length){
    case 1:
      frame_content.style.marginTop = "1px";    
      frame_content.style.fontSize = "110%";
      //frame_content.style.marginTop = "-6px";
      //frame_content.style.fontSize = "140%";
    break;
    case 2:
      frame_content.style.marginBottom = "-2px";    
      frame_content.style.fontSize = "90%";
      break;
    case 3:
      frame_content.style.marginBottom = "-7px"
      frame_content.style.fontSize = "65%";
    break;
    case 4:
      frame_content.style.marginBottom = "-11px"
      frame_content.style.fontSize = "40%";
    break;
  }
  
  frame_cell.appendChild(frame_content)
  
  Ax.addFrameListeners(frame_cell,frame,layer)
  
  Ax.layers[layer].el.appendChild(frame_cell)
}
//#99BBE8



Ax.getFrame = function(frame,layer){
  if(frame > 0){
    return Ext.get(Ax.layers[layer].el.childNodes[frame-1]);
  }
}

Ax.selectFrame = function(frame,layer){
  if(frame < 1){return false;}; //OMG!! PONIES!

  
  if(Ax.preview_mode){
    Ax.preview_frame = frame;
    Ax.preview_increment()
    Ax.controls.pause()
    return;
  }
  
  //wave2.ignore(["c",Ax.tcurrent.frame],Ax.frameUpdateInfo)
  
  if(Ext.get("cbframe")){
  	Ext.get("cbframe").dom.value = frame;
  }
  
  Ax.viewport.findById("layers").getSelectionModel().selectRecords([Ax.layers[layer].record], false)
  //select the layer
  
  Ax.autodiff(); //save current state, etc.
  
  //Set cursor
  Ax.tcurrent.frame = frame;
  Ax.tcurrent.layer = layer;
  //Change Styles
  Ax.selectFrame_core(frame,layer);

  
  
  //wave2.listen(["c",frame], Ax.frameUpdateInfo)

  //change the canvas to new one if possible
  Ax.loadframe(frame,layer)
  
}


Ax.selectFrame_core = function(frame,layer){
  //Add frames if necessary
  if(frame > Ax.tstat.frames - 30){
    Ax.addFrames(50 - (Ax.tstat.frames - frame))
  }
  var top =(Ax.getFrame(frame,layer).getY()-Ext.get(Ax.timeline.el).getY()).toString();
  Ax.timeline.mask.style.top = top+"px"
  var left = (Ax.getFrame(frame,layer).getX()-Ext.get(Ax.timeline.el).getX()).toString();
  Ax.timeline.mask.style.left = left+"px";
  
  Ext.get("timeline_core").parent().scrollChildIntoView(Ax.timeline.mask)
  
}

Ax.insertFrame = function(frame,layer){
  if(frame < 1){return false;}; //OMG!! PONIES!
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}

  Ax.addFrame()
  
  for(var i = 0; i < Ax.layers[layer].keyframes.length; i++){
    if(Ax.layers[layer].keyframes[i] > frame){
      var keyframe_id = Ax.layers[layer].keyframes[i];

      //Ax.layers[layer].keyframes[i] += 1;
      //Ax.canvas_storage[layer][(keyframe_id+1).toString()] = Ax.canvas_storage[layer][keyframe_id.toString()]
      //delete Ax.canvas_storage[layer][keyframe_id.toString()]
      
      Ax.deleteKeyframe(keyframe_id, layer);
      Ax.toKeyframe(keyframe_id+1, layer)
      Ax.setcanvas(keyframe_id+1, layer, Ax.getcanvas(keyframe_id, layer))
      //Ax.deletecanvas(keyframe_id, layer)
      //happens in deleteKeyframe
      
    }
  }
  /*
  for(var i = 0; i < Ax.layers[layer].tweens.length; i++){
    if(Ax.layers[layer].tweens[i] > frame){
      Ax.layers[layer].tweens[i]+=1
    }
  }
  */
  for(var i = frame; i < Ax.tstat.frames; i++){
    Ax.renderFrame(i,layer)
  }
  
  if(Ax.isTween(frame,layer)){
    Ax.tween(Ax.largest_nonempty(frame,layer),Ax.smallest_nonempty(frame,layer),layer); //tween from previous keyframe to no
    if(frame == Ax.tcurrent.frame && layer == Ax.tcurrent.layer){
      Ax.loadframe(frame, layer)
    }
  }
  
}

Ax.deleteFrame = function(frame, layer){
  if(frame < 1){return false;}; //OMG!! PONIES!
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}
  if(frame == 1){
    Ax.msg("Can't delete first frame","You just can't delete the first frame. It's magical so just try to live with it.")
    return false;
  }
  
  if(Ax.isTween(frame, layer)){
    //Ax.msg("Can't delete tweens","Only keyframes greater than 1 can be deleted.")
    //return false;
    //Ax.layers[layer].tweens.splice(Ax.layers[layer].tweens.indexOf(frame),1)
    
    //just delete lol!
  }else if(Ax.isKeyframe(frame, layer)){
    Ax.deleteKeyframe(frame, layer);
  }
  
  //*
  for(var i = 0; i < Ax.layers[layer].keyframes.length; i++){
    if(Ax.layers[layer].keyframes[i] > frame){
      var keyframe_id = Ax.layers[layer].keyframes[i];
      //Ax.layers[layer].keyframes[i] -= 1;
      
      
      
      Ax.deleteKeyframe(keyframe_id, layer);
      Ax.toKeyframe(keyframe_id-1, layer)
      Ax.setcanvas(keyframe_id-1, layer, Ax.getcanvas(keyframe_id, layer))
      //Ax.canvas_storage[layer][(keyframe_id-1).toString()] = Ax.canvas_storage[layer][keyframe_id.toString()]
      //delete Ax.canvas_storage[layer][keyframe_id.toString()]
    }
  }
  /*
  for(var i = 0; i < Ax.layers[layer].tweens.length; i++){
    if(Ax.layers[layer].tweens[i] > frame){
      Ax.layers[layer].tweens[i]-=1
    }
  }*/
  for(var i = frame; i < Ax.tstat.frames; i++){
    Ax.renderFrame(i,layer)
  }
  
  //*/
  Ax.loadframe(frame,layer)
}

Ax.renderFrame2 = function(frame, layer){
  if(frame > Ax.tstat.frames - 30){
    Ax.addFrames(50 - (Ax.tstat.frames - frame))
  }
  return Ax.renderFrame(frame, layer);
}

Ax.renderFrame = function(frame,layer){
  //Add frames if necessary

  switch(Ax.frameType(frame,layer)){
    case "keyframe":
      Ax.toKeyframe_core(frame,layer)
      break;
    case "tween":
      Ax.toTween_core(frame,layer)
      break;
    case "blank":
      Ax.toBlank_core(frame,layer)
      break;
  }
}

Ax.frameType = function(frame,layer){
  if(Ax.isKeyframe(frame,layer) == true){
    return "keyframe"
  }
  if(Ax.isTween(frame,layer) == true){
    return "tween"
  }
  return "blank"

}
Ax.toKeyframe = function(frame,layer,nobroadcast){
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}

  //Add frames if necessary
  if(frame > Ax.tstat.frames - 30){
    Ax.addFrames(50 - (Ax.tstat.frames - frame))
  }
  

  if(!Ax.isKeyframe(frame,layer)){
    Ax.layers[layer].keyframes.push(frame);
    
    if(!nobroadcast){
      Ax.dumpframe2();
      wave2.set(["k",frame,layer],1)
    }
  }
  
  
  
  if(Ax.isTween(frame,layer)){//this never sees light, because the thing above keeps it from ever executing
    //but its still here as a useless brick in case pigs can fly (don't you love cliches?)
    //Ax.layers[layer].tweens.splice(Ax.layers[layer].tweens.indexOf(frame),1)
    //Ax.tween(frame,Ax.smallest_nonempty(frame,layer),layer); //tween from now to next
  }else{
    Ax.tween(Ax.largest_nonempty(frame,layer),frame,layer); //tween from previous keyframe to now
  }
  
  
  
  return Ax.toKeyframe_core(frame,layer)
}

Ax.frameClass = function(frame,layer,frameclass){
  Ax.getFrame(frame,layer).dom.className = "frame "+frameclass;
}

Ax.isTween = function(frame,layer){
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}
  
  if(Ax.isKeyframe(frame, layer)){
    return false;
  }else  if(!Ax.smallest_nonempty(frame, layer)){
    //if last frame in layer
    return false
  }else{
    return true;
  }
  //NO MORE MANUAL TWEEN LISTS!
  //return (Ax.layers[layer].tweens.indexOf(frame) != -1)
}

Ax.isKeyframe = function(frame,layer){
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}
  
  //again, frame 1 is something i screwed up on too early to fix
  
  var kf = (Ax.layers[layer].keyframes.indexOf(frame)!= -1);
  
  //console.log(Ax.layers['Layer 1'].keyframes,frame)
  
  //if(kf == true && !wave2.get(["k",frame,layer])){
  //  wave2.set(["k",frame,layer],1)
  //}
  
  return frame==1?true:kf
}

Ax.toKeyframe_core = function(frame,layer){
  Ax.frameClass(frame,layer,"keyframe");
}

//there is no non-core Ax.toTween as it is supposedly automatic
//scratch that.... idk
Ax.toTween_core = function(frame,layer){
  Ax.frameClass(frame,layer,"tween");
}

Ax.toTween = function(frame,layer){
  //Add frames if necessary
  if(frame > Ax.tstat.frames - 30){
    Ax.addFrames(50 - (Ax.tstat.frames - frame))
  }
  
  //if(Ax.layers[layer].tweens.indexOf(frame) == -1){
  //  Ax.layers[layer].tweens.push(frame);
  //}
  
  return Ax.toTween_core(frame,layer)
}

Ax.deleteKeyframe = function(frame, layer, nobroadcast){
  if(!frame){frame = Ax.tcurrent.frame}
  if(!layer){layer = Ax.tcurrent.layer}
  
  if(frame == 1){return false;} //MAGICAL
  
  if(Ax.isTween(frame, layer)){
    return false;
  }
  
  if(Ax.isKeyframe(frame, layer)){
    //un-keyframe
    if(!Ax.smallest_nonempty(frame, layer)){
      //oh noes, it's the largest
      var c = Ax.smallest_nonempty(frame-1, layer);
      for(var i = Ax.largest_nonempty(frame, layer)+1; i < c; i++){
        Ax.deleteTween(i, layer)
      }
      Ax.toBlank_core(frame, layer)
    }else{
      Ax.toTween(frame, layer);
    }
    
    Ax.layers[layer].keyframes.splice(Ax.layers[layer].keyframes.indexOf(frame),1);
    
    if(!nobroadcast){
      wave2.del(["k",frame,layer])
    }
    Ax.deletecanvas(frame, layer);
     
    //delete Ax.canvas_storage[layer][frame];
    
  }
  
  if(layer == Ax.tcurrent.layer && frame == Ax.tcurrent.frame){
    Ax.loadframe(frame,layer)
  }
}

Ax.deleteTween = function(frame, layer){
  //if(Ax.isKeyframe(frame, layer)) return;
  //Ax.layers[layer].tweens.splice(Ax.layers[layer].tweens.indexOf(frame),1)
  Ax.toBlank_core(frame, layer)
}

Ax.toBlank_core = function(frame,layer){
  Ax.frameClass(frame,layer)
}

Ax.addFrameListeners = function(frame_cell,frame,layer){
  //not very memory friendlyish. stuffs dont get removed when unneeded/unused.
  new Ext.ToolTip({
   target: frame_cell,
   trackMouse: true,
   shadow: false,
   width: 120,
   title: "Loading...",
   html: 'Loading...',
   rframe: frame,
   rlayer: layer,
   listeners: {
   	"show":function(tooltip){
		
		var dataformat = {
			"Shapes": Ax.getshapes(tooltip.rframe, tooltip.rlayer).length
		}, dataoutput = "";
		
		for(var label in dataformat){
			dataoutput += "<span style=\"float: left\">"+label+"</span><span style=\"float: right\">"+dataformat[label]+"</span><br>"
		}
		
		
		var preview_tip = document.createElement("div"); //im not good with Ext dom stuffs
		preview_tip.className = "preview_tip"
    var height = ((tooltip.getBox().width - 12) * Ax.canvasHeight)/Ax.canvasWidth;
    var width = tooltip.getBox().width - 12
		Ext.get(preview_tip).setHeight(height)
		Ext.get(preview_tip).setWidth(width)
		
		
		tooltip.setTitle('Frame '+tooltip.rframe.toString()+" "+tooltip.rlayer.toString())
		tooltip.body.update(dataoutput)
		
		if(Ext.isIE){
		//	preview_tip.innerHTML = "Preview Tips Not Available For Microsoft Internet Explorer"
      //i shoudl be evil and say it's not available anyway, just because IE sucks
    }
		 
		tooltip.body.dom.appendChild(preview_tip)
		
    var canv =  Ax.init_view_core(preview_tip)
		Ax.viewer_load_frame(tooltip.rframe, Ax.export_animation_core(), canv)
    if(canv.no_listener_shapes){
      for(var i = 0; i < canv.no_listener_shapes.length; i++){
         canv.no_listener_shapes[i].scale(width/Ax.canvasWidth,height/Ax.canvasHeight, 0,0);
      }
    }
		//console.log((tooltip.getBox().width * Ax.canvasHeight)/Ax.canvasWidth)
		
		//
	},
	"hide": function(tooltip){
		//make more memory friendlyish
		tooltip.body.dom.innerHTML = "";
	}
   }
  });

}


Ax.create_timeline_mask = function(){
  Ax.timeline.mask = document.createElement("div")
  Ax.timeline.mask.className = "fselect_mask"
  Ax.timeline.el.appendChild(Ax.timeline.mask)
  
   new Ext.ToolTip({
   target: Ax.timeline.mask,
   trackMouse: true,
   shadow: false,
   //width: 120,
   title: 'Loading...',
   html: "Loading...",
   listeners: {
   	"show": function(tooltip){
		tooltip.setTitle('Frame '+Ax.tcurrent.frame.toString()+" "+Ax.tcurrent.layer.toString())
		tooltip.body.update("Selected Frame")
		
	}
   }
   })
}


Ax.reloadTimeline = function(){
	for(var layer in Ax.layers){
		for(var frame = 1; frame < Ax.tstat.frames+1; frame++){
			Ax.renderFrame(frame, layer);
		}
	}
	Ax.msg("Timeline Reloaded","Timeline has been sucessfully rendered")
}

Ax.timelineCleanup = function(){
	Ax.msg("Timeline Cleanup","Timeline has been sucessfully cleaned up."); //meh. it did nothing
}

Ax.initTimeline = function(){
  Ax.layers = {};
  
  Ext.get("timeline_core").dom.innerHTML = ""
  var frameTable = document.createElement("table");
  frameTable.setAttribute("cellspacing","0")
  frameTable.setAttribute("cellpadding","0")
  frameTable.setAttribute("border","0")
  //frameTable.style.border = "1px solid gra"
  var frameTBody = document.createElement("tbody");
  frameTable.appendChild(frameTBody)
  Ext.get("timeline_core").dom.appendChild(frameTable)
  Ax.timeline.el = frameTBody;
  
  Ext.get("timeline_core").parent().on("selectstart",function(event){event.stopEvent();return false})
  Ext.get("timeline_core").parent().on("mousedown", function(event, target){
  	if(target.className == "frame"){
	for(var layer in Ax.layers){
      if(target.parentNode.parentNode == Ax.layers[layer].el){
        Ax.selectFrame(parseInt(target.innerHTML),layer)
        break;
      }
    }
	}
	if(event.button == 2){
		
	}
  //	console.log(event,target)
  })
  Ext.get("timeline_core").parent().on("contextmenu",function(event,target){
    //console.log(event,target)
    event.stopEvent();
//console.log(Ax.tcurrent)
    if(target.className == "fselect_mask" ||( target.innerHTML == Ax.tcurrent.frame.toString() )){
      new Ext.menu.Menu({
        items: [
        {text: "Add Layer", iconCls: "tb_newlayer", handler: function(){Ax.addLayer()}},
        {text: "To Keyframe", iconCls: "tb_addkeyframe", handler: function(){Ax.toKeyframe()}},
        {text: "Insert Frame", iconCls: "tb_insertframe", handler: function(){Ax.insertFrame()}},
        
        {text: "Delete Frame", iconCls: "tb_delframe", handler: function(){Ax.deleteFrame()}}
        ]
      }).showAt(event.xy)
    }else{
      new Ext.menu.Menu({
        items: [
         {text: "Add Layer", iconCls: "tb_newlayer", handler: function(){Ax.addLayer()}}
        ]
      }).showAt(event.xy)
    }
  })
  
  Ax.create_timeline_mask();
}

/*
Ext.onReady(function(){
  Ax.initTimeline()
  Ax.addLayer()
  Ax.addFrames(150)
})
//*/ /**/ //END





 /*JS File: ../js/animation/preview.js*/ 


 Ax.performance = 0;

Ax.preview_increment = function(noplay){
  var start = (new Date()).getTime();
  /*
  Ax.preview_frame = Ax.viewer_load_frame( //load the next frame
  ((Ax.preview_frame)?Ax.preview_frame:Ax.tcurrent.frame), //if no current frame, load from the current editor frame
  Ax.preview_markup, //the la magickal poop!
  Ax.preview //the canvas
  ) + (noplay?0:1);
  */
  
  
  Ax.preview_frame = (Ax.preview_frame?Ax.preview_frame:Ax.tcurrent.frame)

  
  if(!Ax.preview){
    Ax.init_preview();
  }
  
  Ax.preview.deleteAll();
  
  for(var layer in Ax.layers){
    var shapes = Ax.getshapes(Ax.preview_frame, layer);
    Ax.loadShapes(shapes, true, Ax.preview);
  }
  if(!Ax.preview_frame){
    Ax.preview_frame = 1;
  }
  //console.log(Ax.preview_frame)
  Ax.selectFrame_core(Ax.preview_frame,Ax.tcurrent.layer)
  Ax.preview_frame++;
  
  if(Ax.preview_frame > Ax.count_frames(Ax.layers)){
    Ax.preview_frame = 1;
  }
  
  var end = (new Date()).getTime()
  
  Ax.performance = end-start;
  
  if(!noplay) Ax.preview_timeout = setTimeout(function(){Ax.preview_increment()}, Math.max(0,(1000/Ax.framerate)-Ax.performance));
}

Ax.preview_msg = function(){
    Ax.msg("Preview","Preview is for viewing! Head over to the Canvas tab to edit.")
  }


Ax.init_preview = function(){
  
  if(Ax.canvas){
    Ax.autodiff(); //insures its the current data.
  }
  $("previewcanvas").innerHTML = "";
  
  Ext.get("previewcanvas").un("mousedown",Ax.preview_msg);//bai bai lyst3n3rz
  
  Ax.preview = Ax.init_view($("previewcanvas"), Ax.canvasWidth, Ax.canvasHeight);
  
  Ext.get("previewcanvas").on("mousedown",Ax.preview_msg);
  
  Ax.preview_markup = Ax.export_animation_core();
  Ax.preview_frame = null;
}





 /*JS File: ../js/animation/player.js*/ 


 
Ax.player_increment = function(){
    var start = (new Date()).getTime();
    Ax.player_frame = Ax.viewer_load_frame( //load the next frame
	((Ax.player_frame) ? Ax.player_frame : 1), //if no current frame, load from the current editor frame
 	Ax.player_markup.layers, //the la magickal poop!
 	Ax.player //the canvas
	) +
    1;
    
    Ax.player_timeout = setTimeout(function(){
        Ax.player_increment()
    }, 1000 / ((Ax.player_markup.framerate) ? Ax.player_markup.framerate : 12));
}

Ax.player_play = function(){
    Ax.player_increment();
}
Ax.player_pause = function(){
    clearTimeout(Ax.player_timeout);
}

Ax.init_player = function(markup){
    //if (Ext.isIE == true) { //yes. i know. browser sniffing is bad
    //    $("playercanvas").style.position = "absolute";
    //    $("playercanvas").style.left = "5%";
    //}
    if (typeof markup == typeof "insanelygreat") {
        markup = Ext.util.JSON.decode(markup)
    }
    $("playercanvas").innerHTML = "";
    Ax.player = Ax.init_view($("playercanvas"), markup.width, markup.height);
    Ax.player_markup = markup;
    Ax.player_frame = null;
}

Ax.player_import = function(){
    Ax.viewport.findById("maintabpanel").activate(0)
    Ax.import_animation(Ax.player_markup);
}



 /*JS File: ../js/data/format.js*/ 


 /*The magickal ALEON (Animation Lightweight Ecmascript Object Notation Format)*/
//or maybe AXON woudl be better.
//you can call it Awesome Lightweight Extreme Online New-animation-format if you like
//or other countless bacronyms
//sorry for the ridiculous name

/*
ALEON/Axff/Xff


{
  frames: 0, //frame count (required)
  tcframe: 1, //current frame
  tclayer: "Layer 1", //current layer
  generator: { //Ax.v dump
    app: "Ajax Animator",
    release: 0.2,
    build: 232
  },
  creation: 1214687653614, //unix epoch of creation
  modified: 1214687673324, //last modified date
  contrib: [ //array of contributors
    "k7d13x32fc" //10 digit auto-generated id for session, or username
  ],
    
  layers: { //where all the data is stored
    "Layer 1": {
      keyframes: [1,5,10,15,20],
      //tweens: [2,3,4,6,7,8,9,11,12,13,14,16,17,18,19], //this one is optional and not included by default
      src: [ //standard OPF data
        {type: "rect", id: "somelongidstring", x: 31, y: 32, ...}
      ]
    }
  }
}
*/


//format information
Ax.format = {
  support: {//format support. minimum version, maximum version
    min: 20,
    max: 21
  },
  revision: 21 //the version the app exports
}


Ax.emptyAnimation = {
  layers: {
    "Layer 1": {
      keyframes: [1],
      visible: true,
      src: {
        "1":[]
      }
    }
  }
}

Ax.new_animation = function(){
  Ax.import_animation(Ext.ux.clone(Ax.emptyAnimation))
  //Ax.history_add("New Animation")
}

Ax.export_animation_core = function(input,format){
  var layers = {};
  for(var layer in Ax.layers){
    layers[layer] = {
      keyframes: Ax.layers[layer].keyframes,
      visible: Ax.layers[layer].visible,
      //tweens: Ax.layers[layer].tweens, //this is not necessary
      src: Ax.getlayercanvas(layer)
    }
  }
  return layers;
}

Ax.export_animation = function(input, format){
  if(!input){
    input = {};
  }
  
  input.name = Ax.animation.name; //quite important to have this up here so you can easily identify the animation from a quick glance
	
  if(!input.creation){
    input.creation = (new Date()).getTime()
  }
  
  if(typeof input.contrib != typeof ['antimatter15','is','awesome']){
    input.contrib = []; //an array
  }
  if(input.contrib.indexOf((Ax.userid)?Ax.userid:"anonymous") == -1){
    input.contrib.push((Ax.userid)?Ax.userid:"anonymous"); //add user to list of contributors if not there already
  }
  
  input.modified = (new Date()).getTime();
  input.generator = Ax.v;
    
  input.revision = Ax.format.revision;
  
  input.tcframe = Ax.tcurrent.frame;
  input.tclayer = Ax.tcurrent.layer;
  
  input.layers = Ax.export_animation_core(); //the most important part: the data
  
  input.width = Ax.canvasWidth;
  input.height = Ax.canvasHeight;
  
  input.framerate = Ax.framerate;
  
  if(format == "json"){
    return Ext.util.JSON.encode(input);
  }else{
    return input;
  }
}

Ax.import_animation = function(markup){
  if(typeof markup == typeof "tehkooliest"){ //if its in json, then decode it first
    markup = Ext.util.JSON.decode(markup)
  }
  Ax.setAnimationName(markup.name)
  //set the name for the animation in that little box in the toolbar. overly hackish, I know. Seriously, acessing dom?
  Ax.animation.markup = markup;
  
  Ax.canvasWidth = markup.width?markup.width:480
  Ax.canvasHeight = markup.height?markup.height:272
  Ax.canvasSize_core();
  
  Ax.framerate = markup.framerate?markup.framerate:12;
  
  Ax.import_animation_core(markup.layers);
  
  //this is quite horrible to the code. but google wants it
  Ax.selectFrame((markup.tcframe)?markup.tcframe:1,"~1")//(markup.tclayer)?markup.tclayer:"Layer 1");
  
}

Ax.test_animation_markup = function(markup){
  if(typeof markup != typeof "actionwoot"){
    return false; //its not valid, only takes json formatted string
  }
  try{
    markup = Ext.util.JSON.decode(markup); //attempt to decode
  }catch(err){
    return false;
  }
  if(!markup){
    return false; //its not valid, it didn't get through
  }
  if(typeof markup != typeof ({woot: "ness"})){
    return false; //its not the right type
  }
  if(typeof markup.layers != typeof ({ello: "world"})){
    return false;
  }
  
  return markup;
}

Ax.import_animation_core = function(layers){
  Ax.reloadCanvas_core(); //try resolving some issues;
  
  Ax.viewport.findById("layers").getStore().removeAll(); //remove all entries from layers panel
  Ax.initTimeline(); //reset timeline
  //Ax.canvas_storage = {}; //empty canvas storage
  Ax.removeallcanvas();
  
  Ax.canvas.unselect();//unselect the canvas, saves a nasty bug
  Ax.deleteAll(); //clear canvas
  
  
  Ax.layers = {};//reset layers object
  //Ax.tstat = {layers: 0, frames: 0}
  Ax.tstat.layers = 0;
/*
for(var firstlayer in layers){
  Ax.tcurrent.layer = firstlayer;
  Ax.tcurrent.frame = 1;
  Ax.loadShapes(layers[firstlayer].src[1]);
  break;
}  
*/


//wave2.fire_evt = false;

var lc = 1;
for(var layerx in layers){ //loop through layers
    var layer = "~"+(lc++);

    Ax.addLayer(layer); //add layer
    Ax.layers[layer].keyframes = layers[layerx].keyframes; //set keyframes
    
    for(var i = 0; i < Ax.layers[layer].keyframes.length; i++){
      wave2.set(["k",Ax.layers[layer].keyframes[i],layer],1)
    }
    Ax.layers[layer].visible = Ax.layers[layer].visible
    //Ax.canvas_storage[layer] = layers[layer].src; //load canvas src
    
    
    
    Ax.setlayercanvas(layer, layers[layerx].src)
    
    //Ax.loadframe(1, layer); //note: this is a hack!
    //console.log(layers[layer].src);
    //*
    for(var i = 0; i < layers[layerx].keyframes.sort(function(a,b){return b-a})[0] + 1; i++){
      Ax.renderFrame2(i + 1,layer); //render frame to timeline, (renderFrame may be better)
      	//if(layers[layer].keyframes.indexOf(i+1) != -1){
        //  Ax.toKeyframe(i+1, layer)
        //}
    }
    //*/
    
  }

}

Ax.reload_animation = function(){
  try{
    Ax.import_animation(Ax.export_animation(Ax.animation.markup))
  }catch(err){
    return Ax.msg("Animation Recovery","Animation recovery has failed due to error: "+err)
  }
  Ax.msg("Animation Reloaded","The current animation was reloaded. This hopefully has resolved most issues related to the timeline and other components.")
}




 /*JS File: ../js/data/formatgui.js*/ 


 /*
 * all the remarkably interesting code that displays that box to show you the markup
 * that magical dialog that asks if it wants to steal all your private files on your drive
 * that cool box requesting to steal items on your clipboard
 * that field that attempts to steal your favorite sites
 * that stuff that goes on that tries to carpetbomb your desktop with random aliens :P
 * yep, all that magic takes place..... here.
 */
Ax.autoimport = function(markup){
    var jsonmarkup = Ax.test_animation_markup(markup);
    if (jsonmarkup != false) {
        if (jsonmarkup.revision) {
            if (Math.round(jsonmarkup.revision) > Ax.format.support.max) {
                Ax.msg("Warning! Proof of time travel", "It seems that the animation you are attempting to load was created with a future version of the ajax animator. It may contain data that can not be loaded properly in this version, or may load perfectly fine.")
            }
            if (Math.round(jsonmarkup.revision) < Ax.format.support.min) {
                Ax.msg("Warning!", "The animation you are attempting to load seems to be created by an older, unsupported version. It is more than likely some information here will not load properly.")
            }
        }
        Ax.import_animation(markup);
    }
    else {
        if (markup.indexOf(";;") != -1) {
            Ax.msg("Unable to load animation!", "The animation looks like data from the AXML format used by Ajax Animator 0.14.7 and below. It is not supported natively in this release due to the usage of a new format in 0.20+.")
        }
        else {
            Ax.msg("Unable to load animation!", "The animation could not be loaded because it is malformed. Check the data for corruption, or from an unsupported source.")
        }
    }
}


Ax.animationinfo = function(type){
    //graphically displays metadata in animation, also some statistics, etc.
    
    if (type == "core") {
        return "<b>" + Ax.animation.name + ":</b><br />Generator: " + (Ax.animation.markup.generator ? (Ax.animation.markup.generator.app+" build "+Ax.animation.markup.generator.build) : "Unknown") +
        "<br />Format Version: " +
		(Ax.animation.markup.revision ? Ax.animation.markup.revision : "Unknown") + 
		"<br />Creation Date: " +
        ((Ax.animation.markup.creation) ? Ax.animation.markup.creation : "Unknown") +
        "<br />Last Modified Date: " +
        ((Ax.animation.markup.modified) ? Ax.animation.markup.modified : "Unknown") +
        "<br />Contributors: " +
        ((Ax.animation.markup.contrib) ? Ax.animation.markup.contrib : ['Unknown']).join(",") +
        "<br />Size: " +
        Ax.export_animation(Ax.animation.markup, "json").length +
        "<br />Layers: " +
        Ax.tstat.layers +
        "<br />Frames: " +
        Ax.count_frames()
    }
    
    (new Ext.Window({
        title: "Animation Info - " + Ax.animation.name,
        iconCls: "tb_about",
        width: 300,
        height: 200,
		layout: "fit",
		items: {
			border: false,
 	        html: Ax.animationinfo("core")
		},
        buttons: [{
            text: "Update",
            iconCls: "reload_icon",
            handler: function(){
                this.ownerCt.items.first().body.update(Ax.animationinfo("core"));
				//this.ownerCt.layout.body.update(Ax.animationinfo("core"))
            }
        }, {
            text: "Close",
            iconCls: "close",
            handler: function(){
                this.ownerCt.close()
            }
        }]
    
    })).show(document.body)
}



 /*JS File: ../js/data/save.js*/ 


 /**
 * @author antimatter15
 * 
 * This is pretty cool rite?
 */
 
Ax.save = {
    text: function(){
        (new Ext.Window({
            title: "Save Animation As Text",
            iconCls: "tb_save",
            width: 300,
            height: 300,
            buttons: [{
                text: "Update",
                iconCls: "reload_icon",
                handler: function(){
                    this.ownerCt.findById("outtext").setValue(Ax.export_animation(Ax.animation.markup, "json"))
                }
            }, {
                text: "Close",
                iconCls: "close",
                handler: function(){
                    this.ownerCt.close()
                }
            }],
            layout: "border",
            items: [{
                region: "north",
                border: false,
                html: "You may copy the text below and save it somewhere to open later from the File->Open->From Text menu option."
            }, {
                region: "center",
                layout: "fit",
                border: false,
                items: {
                    id: "outtext",
                    xtype: "textarea",
                    style: "font-size: 9px",
                    value: Ax.export_animation(Ax.animation.markup, "json")
                }
            }]
        })).show(document.body)
    },
    
    computer: function() { alert("commented out by bntr"); },
    /* bntr: uses some proxy.php?
    computer: function(data, name, base64){
        Ax.ajax({
            url: Ax.files.save_proxy,
            params: {
                action: "test"
            },
            req_type: "checkproxy",
            success: function(e){
                //console.log(e)
                if (e.responseText == "working") {
                    Ax.save.comp_iframe(data, name, base64, e.alt_url); //server connection works, try the iframe awesomeness
                }
                else {
                    Ax.save.comp_datauri(data); //apparently the server doesn't work
                }
            },
            failure: function(){
                Ax.save.comp_datauri(data); //the connection failed, so try the datauri method
            }
        })
        
    },
    comp_datauri: function(data, base64){
        window.location = "data:application/octetstream;base64," + base64?data:(Ext.ux.base64.encode((data)?data:Ax.export_animation(Ax.animation.markup, "json")));
    },
    comp_iframe: function(data, name, base64, alt_proxy){ //looks like its not actually an iframe -_-
        Ax.msg("Saving...", "The request is being processed by the server and may take a long time depending on the size of the animation." +
        "<form id=\"save_form\" method=\"POST\" action=\"" +
        (alt_proxy?alt_proxy:Ax.files.save_proxy) +
        "\"><input type=\"hidden\" name=\"encoding\" value=\"" +
		((base64)?"base64":"raw")+
		"\"><input type=\"hidden\" name=\"name\" value=\"" +
        ((name)?name:Ax.animation.name) +
        "\" /><input type=\"hidden\" name=\"action\" value=\"work\" /></form>");
        var new_input = document.createElement("input")
        new_input.type = "hidden";
        new_input.name = "data";
        new_input.value = (data)?data:Ax.export_animation(Ax.animation.markup, "json");
        Ext.get("save_form").dom.appendChild(new_input); //waste of Ext, I know
        Ext.get("save_form").dom.submit();
    }
    */
}



 /*JS File: ../js/data/open.js*/ 


 /**
 * @author antimatter15
 */

 
 Ax.open = {
    text: function(){
        (new Ext.Window({
            title: "Open Animation From Text",
            iconCls: "tb_open",
            width: 300,
            height: 300,
            buttons: [{
                text: "Load",
                iconCls: "load",
                handler: function(){
                    Ax.autoimport(this.ownerCt.findById("loadtext").getValue())
                }
            }, {
                text: "Close",
                iconCls: "close",
                handler: function(){
                    this.ownerCt.close()
                }
            }],
            layout: "border",
            items: [{
                region: "north",
                border: false,
                html: "Paste some data acquired from the save to text button here."
            }, {
                region: "center",
                layout: "fit",
                border: false,
                items: {
                    id: "loadtext",
                    xtype: "textarea",
                    style: "font-size: 9px"
                }
            }]
        })).show(document.body)
    },
    // bntr
    file: function() { alert("removed by bntr"); },
    /*
    file: function(){
        (new Ext.Window({
            title: "Open Animation From Computer",
            iconCls: "tb_open",
            width: 400,
            height: 105,
            buttons: [{
                text: "Load",
                iconCls: "load",
                handler: function(){
                    //console.log(this.ownerCt.findById("loadform"))
                    this.ownerCt.findById("loadform").form.submit({
                        url: Ax.files.open_proxy,
                        success: function(form, action){
                            Ax.autoimport(Ext.util.JSON.encode(action.result.data))
                        },
                        failure: function(form, action){
                            Ax.toastMsg("Upload Failed", action.failureType + action.result.error +
                            " Animation could not be loaded. If trying again fails, try pasting the file's contents into the Open from Text dialog.")
                        }
                    })
                    Ext.Ajax.request({
                        url: Ax.files.open_proxy,
                        params: {
                            action: "test"
                        },
                        success: function(e){
                     
                            if (e.responseText != "working") {                   
                                Ax.toastMsg("Probable Failure", "Upload handling server appears not to be working")
                            }
                        },
                        failure: function(){
                            Ax.toastMsg("Probable Failure", "Upload handling server appears not to be working")
                        }
                    })
                                       
                }
            }, {
                text: "Close",
                iconCls: "close",
                handler: function(){
                    this.ownerCt.close()
                }
            }],
            border: false,
            items: [{
                layout: "fit",
                html: "Please locate the saved animation from your computer.",
                border: false
            }, {
                border: false,
                id: "loadform",
                xtype: "form",
                fileUpload: true,
                listeners: {
                    beforeaction: function(){
                        Ax.msg("Uploading Data", "The animation file is being uploaded to the server.")
                    }
                },
                items: [{
                    name: "file",
                    xtype: "field",
                    fieldLabel: "Animation File",
                    inputType: "file"
                },{
					name: "action",
					xtype: "hidden",
					value: "work"
				}]
            }]
        })).show(document.body)
    },
    */
    url: function(){
        (new Ext.Window({
            title: "Open Animation From URL",
            iconCls: "tb_open",
            width: 350,
            height: 100,
            buttons: [{
                text: "Load",
                iconCls: "load",
                handler: function(){
					Ext.MessageBox.alert("Functionality Disabled","Loading an animation from an external server has been disabled for (pseudo) security purposes.")
                    //Ax.autoimport(this.ownerCt.findById("loadtext").getValue())
                }
            }, {
                text: "Close",
                iconCls: "close",
                handler: function(){
                    this.ownerCt.close()
                }
            }],
            //layout: "border",
            border: false,
            items: [{
                layout: "fit",
                html: "Place the location of the online resource to load from.",
                border: false
            }, {
                label: "URL",
                id: "loadurl",
                style: "width: 100%",
                xtype: "textfield"
            }]
        })).show(document.body)
    }
}



 /*JS File: ../js/data/export.js*/ 


 /**
 * @author antimatter15
 */



Ax.ex = {}; //short for Ax.export, but sadly aptana goes crazy when i do that, so why not?





 /*JS File: ../js/data/export/array.js*/ 


 /**
 * @author antimatter15
 * This is sorta critical part of the other formats.
 * It makes making other formats easier
 * Especially those incapable of porting the tweening engine to
 */
Ax.ex.array = function(format){ //returns an array of every single frame (single layered) tweened when necessary
    Ax.autodiff(); //read the comment in player.js
    var output = [], frame = 1, total_frames = Ax.count_frames(Ax.layers);
    
    
    
    for(;frame < total_frames;frame++){
      for(var layer in Ax.layers){
        var shapes = Ax.getshapes(frame, layer);
        output.push(shapes)
        //Ax.loadShapes(shapes, true, Ax.preview);
      }
    }
    //is it possible that an infinite loop finishes?

    if (format == "json") {
        return Ext.util.JSON.encode(output);
    }
    return output;
}

Ax.ex.array.save = function(){
    Ax.msg("Notes on exporting to OnlyPaths JSON Frame List", "Export to OnlyPaths JSON Frame List does not contain layer or tween data.")
    Ax.save.computer(Ext.util.JSON.encode(Ax.ex.array()), Ax.animation.name + ".opf");
}



 /*JS File: ../js/data/export/flash.js*/ 


 /**
 * @author antimatter15
 *
 * Wow! Flash! isn't it all about this these days? Oh wait. wrong version
 * Who cares? Flash is everwhere. It may suck in some ways (cross-platformness)
 * but its better than the competition (*cough* silverlight *cough*)
 * 
 * This probably doesn't make much sense. I can't even make sense of this.
 * But IDK. this is just another comment on comments, which is now a commment on commments on comments
 * because meta-thinking is good, metacommenting should also be good.
 */
 
/* bntr
 
Ax.ex.swf = function(){ //normally this actually does something, but this is a rare occasion where nothign happens
    return false; //boo hoo
}

Ax.ex.swf.save = function(){ //savenessy
    Ax.msg("Notes on exporting to Flash", "Export to flash currently uses the limited freemovie library. Better flash export will be available later using another library such as Transform SWF. ");    
    Ax.ex.swf.check(); //start the magickal process
}


Ax.ex.swf.check = function(){
    Ax.ajax({
        url: Ax.files.export_swf, //the magickal server
        params: {
            "action": "test" //I say magickal too much don't I?
        },
        success: function(e){ //when the magickalness happens
            if (e.responseText != "working") { //lets test if its working
                Ax.ex.swf.connect_fail(); //waaah! Its failing!
            } 
            else {
                //woot it passed preliminary tests!
                Ax.ex.swf.upload(); //awesome insane wootness!
            }
        },
        failure: function(){
            Ax.ex.swf.connect_fail(); //oh. sure. I don't believe you. If it fails then it fails? Nonsense
        }
        
    })
}

Ax.ex.swf.upload = function(){ //where the cool stuff happens
    Ax.ajax({ //do Ajaxy stuffs
        url: Ax.files.export_swf, //uh, same file
        params: {
            "action": "work", //WORK!
            "width": Ax.canvasWidth,
            "height": Ax.canvasHeight,
            "animation": Ax.ex.array("json") //okay, so I did it, I made Ax.ex.array("json").
        },
        success: function(e){ //YESs!
            Ax.save.computer(e.responseText, Ax.animation.name + ".swf", true); //save to computer using magikalness
        },
        failure: function(){
            Ax.ex.swf.connect_fail(); //what? its not supposed to happen! I already did preliminary tests! or... did you cheat?
        }
    })
}

Ax.ex.swf.connect_fail = function(){
    Ax.toastMsg("Error!", "Connection to SWF (Flash) compilier failed!"); //YOU PHAIL!
}
*/


 /*JS File: ../js/data/export/silverlight.js*/ 


 /**
 * @author antimatter15
 * 
 * I really don't care about silverlight, but its a nifty feature to brag about
 */

/* bntr

Ax.ex.silverlight = function(){
    var data = Ax.ex.array(), //the magic behind it all;
 setup = '<Canvas xmlns="http://schemas.microsoft.com/client/2007" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">\n', //my little header
	draw = ""
    for (var i = 0; i < data.length; i++) {
		content = [];
        for (var s = 0; s < data[i].length; s++) {            
            switch (data[i][s].type) {
                case "line":
                    content.push(Ax.ex.silverlight.line(data[i][s]))
                    break;
                case "rect":
                    content.push(Ax.ex.silverlight.rect(data[i][s]))
                    break;
				case "ellipse":
					content.push(Ax.ex.silverlight.ellipse(data[i][s]))
					break;
				case "path":
					content.push(Ax.ex.silverlight.path(data[i][s]))
					break;
				case "text":
					content.push(Ax.ex.silverlight.text(data[i][s]))
					break;
				case "image":
					content.push(Ax.ex.silverlight.image(data[i][s]))
					break;
            }
        }
		draw += content.join("\n")+"\n";
    }
    return setup + draw + "</Canvas>";
}

    
Ax.ex.silverlight.line = function(shape){
	return new Ext.XTemplate('<Line X1="{left}" Y1="{top}" Fill="{fillColor}" Stroke="{lineColor}" X2="{[values.left+values.width]}" Y2="{[values.top+values.height]}"  StrokeThickness="{lineWidth}" />').apply(shape)
}

Ax.ex.silverlight.rect = function(shape){
	return new Ext.XTemplate('<Rectangle Canvas.Left="{left}" Canvas.Top="{top}" Fill="{fillColor}" Stroke="{lineColor}" Width="{width}" Height="{height}" StrokeThickness="{lineWidth}"><Rectangle.RenderTransform><RotateTransform Angle="{[Ax.parseTransform(values.transform)[0]]}"/></Rectangle.RenderTransform></Rectangle>').apply(shape)
}

Ax.ex.silverlight.path = function(shape){
	return new Ext.XTemplate('<Path Data="{points}"  Fill="{fillColor}" Stroke="{lineColor}" StrokeThickness="{lineWidth}" />').apply(shape)
}

Ax.ex.silverlight.text = function(shape){
	return new Ext.XTemplate('<TextBlock FontSize="{textSize}" Fill="{fillColor}" Stroke="{lineColor}"  FontFamily="{textFamily}" Canvas.Left="{left}" Canvas.Top="{top}">{text}</TextBlock>').apply(shape)
}

Ax.ex.silverlight.image = function(shape){
	return new Ext.XTemplate('<Rectangle Canvas.Left="{left}" Canvas.Top="{top}" Width="{width}" Height="{height}"><Rectangle.Fill><ImageBrush ImageSource="{href}" /></Rectangle.Fill></Rectangle>').apply(shape)
}

Ax.ex.silverlight.ellipse = function(shape){
	return new Ext.XTemplate('<Ellipse Canvas.Left="{left}" Fill="{fillColor}" Stroke="{lineColor}" StrokeThickness="{lineWidth}" Canvas.Top="{top}" Width="{width}" Height="{height}" />').apply(shape)

}
Ax.ex.silverlight.save = function(){
	//return Ax.save.computer(Ax.ex.silverlight(),Ax.animation.name+".xaml")
	Ax.msg("Notes on exporting to Silverlight (XAML)","Export to Silverlight is not complete, animations will be condensed to a single canvas of overlapping shapes and some shape data may not be exported.");
	Ax.save.computer(Ax.ex.processing(),Ax.animation.name+".pde")
}

*/

 /*JS File: ../js/data/export/javafx.js*/ 


 /**
 * El Wootyness!
 * Uh... Java
 * So?
 * Um
 * hai
 * I don't actually know java.
 * oh crap.
 * @author Kevin
 */

/* bntr

Ax.ex.javafx = function(){
	
}

Ax.ex.javafx.save = function(){

	Ext.MessageBox.alert("JavaFX Export Not Available","We have not finished implementing JavaFX export.")	
}

*/


 /*JS File: ../js/data/export/processing.js*/ 


 /**
 * @author antimatter15
 * I'm only making this because this is a cool language
 * I wouldn't even know about Processing if not for John Resig's Processing.JS
 * so yeah, this is sorta intended to be played on processing.js
 */

/* bntr

Ax.ex.processing = function(){
    var data = Ax.ex.array(), //the magic behind it all;
 setup = ["//The compilier for this was quickly hacked together", //my little header
 "int frame = 0;\nint frame_total = "+data.length+";", //some variable declarations
 "void setup(){", //the function start
 "size(480, 272);", //set the size of the canvas
 "frameRate(12);", //set the framerate (fps)
 "smooth();",
 "}\n"].join("\n"), //end the function
    content = [], //the magical content
    draw = ["void draw(){", //declare function
	"if(frame != frame_total){", //if its not the last frmae
	"frame += 1;", //increment it
	"}else{", //but itf it is the last frame
	"frame = 1;", //reset
	"}", //end if
	 "background(#FFFFFF);", //reset the canvas
	 "switch(frame){\n"
	 ].join("\n")
	
    for (var i = 0; i < data.length; i++) {
		content = [];
        for (var s = 0; s < data[i].length; s++) {
            content.push(Ax.ex.processing.stroke(data[i][s]))
            content.push(Ax.ex.processing.strokewidth(data[i][s]))
            content.push(Ax.ex.processing.fill(data[i][s]))
            
            switch (data[i][s].type) {
                case "line":
                    content.push(Ax.ex.processing.line(data[i][s]))
                    break;
                case "rect":
                    content.push(Ax.ex.processing.rect(data[i][s]))
                    break;
				case "ellipse":
					content.push(Ax.ex.processing.ellipse(data[i][s]))
					break;
				case "text":
					content.push(Ax.ex.processing.text(data[i][s]));
					break;
            }
        }
		draw += "case "+(i+1)+":\n"+content.join("\n")+"\nbreak;\n";
    }
    return setup + draw+"}\n}";
}
Ax.ex.processing.stroke = function(shape){
    return "stroke(" + shape.lineColor + ");";
}

Ax.ex.processing.strokewidth = function(shape){
    return "strokeWeight(" + shape.lineWidth + ");";
}

Ax.ex.processing.fill = function(shape){
    return "fill(" + shape.fillColor + ");";
}

Ax.ex.processing.line = function(shape){
    return "line(" +[shape.left,shape.top,shape.left+shape.width,shape.top+shape.height].join(", ") + ");";
}
Ax.ex.processing.text = function(shape){
    return "text(" +['"'+shape.text+'"',shape.left,shape.top].join(", ") + ");";
}

Ax.ex.processing.rect = function(shape){
    return "rect(" +[shape.left,shape.top,shape.width,shape.height] .join(", ") + ");";
}

Ax.ex.processing.ellipse = function(shape){
    return "ellipse(" +[shape.left,shape.top,shape.width,shape.height] .join(", ") + ");";
}
Ax.ex.processing.save = function(){
	Ax.msg("Notes on exporting to Processing","Export to processing is not complete, data such as images, paths, polygons, and rotation will not be exported. Also, it does not use tweening so the files will be massive.");
	Ax.save.computer(Ax.ex.processing(),Ax.animation.name+".pde")
}

*/

 /*JS File: ../js/data/export/gif.js*/ 


 /**
 * @author antimatter15
 *
 * Why not? Its good to bridge Vector and Raster tech.
 * 
 * GIF is awesome, APNG is better, but nothing supports it
 * so whatever. GIF is here to stay, and its partly to blame
 * on IE 6.0 which sucks at transparent PNGs. darn you MSFT!
 */
Ax.ex.gif = function(){
    return false;//it turns out that the SWF generator was a copy+paste of this one.
    //but i decided to comment that one and ..... abandon this one. :(
}

Ax.ex.gif.save = function(){
    Ax.msg("Notes on exporting to Animated GIF", "Export to Animated GIF is not complete, data such as images and rotation will not be exported.")
    Ax.ex.gif.check(); //start the process
}


Ax.ex.gif.check = function(){
    Ax.ajax({
        url: Ax.files.export_gif,
        params: {
            "action": "test"
        },
        success: function(e){
            if (e.responseText != "working") {
                Ax.ex.gif.connect_fail()
            }
            else {
                //woot it passed preliminary tests!
                Ax.ex.gif.upload();
            }
        },
        failure: function(){
            Ax.ex.gif.connect_fail(); //you know what would be really hardcore? making a rant and posting it here.
            /*
             * The folllowing space is reserved for a random rant.
             */
        }
        
    })
}

Ax.ex.gif.upload = function(){
    Ax.ajax({
        url: Ax.files.export_gif,
        params: {
            "action": "work",
            "width": Ax.canvasWidth,
            "height": Ax.canvasHeight,
            "animation": Ax.ex.array("json")
        },
        success: function(e){
            Ax.save.computer(e.responseText, Ax.animation.name + ".gif", true);
        },
        failure: function(){
            Ax.ex.gif.connect_fail()
        }
    })
}

Ax.ex.gif.connect_fail = function(){
    Ax.toastMsg("Error!", "Connection to GIF compilier failed!")
}




 /*JS File: ../js/data/export/smil.js*/ 


 /**
 * El Wootyness!
 * Uh... Java
 * So?
 * Um
 * hai
 * I don't actually know java.
 * oh crap.
 * @author Kevin
 */


Ax.ex.smil = function(){
	
}

Ax.ex.smil.save = function(){
	Ext.MessageBox.alert("SMIL Export Not Available","I'm trying to get a new diff subsystem which will allow better export and SMIL will be the first use for it.")	
}




 /*JS File: ../js/misc/help/tips.js*/ 


 /*
 * those random helpful usage tips window(s) that pops up for no apparent reason. demonstrating common sense.
 * i donno, they're probably somewhat helpful. and guessing that nobody other than me really uses it as much
 * as me, or nobody really knows special tricks that I know..... whatever. anyway. this isn't really helpful
 * is it?
 *
 * I'll try to copy something *good* like krita or the gimp for the layout for this thing.
 * I'm debating whether I should make this appear when you start it. woudl that work?
 * I'm probably talking to my self right now. and hopefully nobody will read this. but you nver know.
 */
//.... yes i did..... i totally copied Kate :P

Ax.tips_array = [];

Ax.showTips = function(){
    if (!Ax.tipsWindow) {
        Ax.tipsWindow = new Ext.Window({
            title: "Tip of the Day - Ajax Animator",
            iconCls: "tb_tip",
            layout: "border",
            width: 300,
            height: 200,
			minimizable: true,
            items: [{
                region: "north",
                html: "<center><h1 class='tiptitle'>Did you know...?</h1></center><br>",
                border: false
            }, {
                region: "center",
                html: Ax.getTipData(),
                border: false
            }],
            buttons: [{
                text: "Previous",
                iconCls: "arrow_prev",
				handler: function(){
					Ax.tipIndex--;
					this.ownerCt.layout.center.panel.body.update(Ax.getTipData())
				}
            }, {
                text: "Next",
                iconCls: "arrow_next",
                handler: function(){
					Ax.tipIndex = (Ax.tipIndex+1) % Ax.tips_array.length
                    this.ownerCt.layout.center.panel.body.update(Ax.getTipData())
                }
            }, {
                text: "Close",
                iconCls: "close",
                handler: function(){
                    this.ownerCt.close()
                }
            }]
        })
    	Ax.tipsWindow.on("minimize", function(){
			Ax.tipsWindow.toggleCollapse();
		})
		Ax.tipsWindow.on("beforeclose", function(){
			Ax.tipsWindow.hide();
			return false;
		})
	}
    Ax.tipsWindow.show(/*document.body*/)
}


Ax.getTipData = function(){
    
    if (!Ax.tipIndex) {
	
	//var today = 
	
	Ax.tipIndex = Math.floor( //floor it
	((new Date()).getTime() //get today's date
	- 2*2*2*2*2*3*3*42227*100000//Yes, I have an iPhone
	)/( //divide it by
	1000*60*60*24//A Day
	) % Ax.tips_array.length); //and get the remainder
    }
    return "<center>" + Ax.tips_array[Ax.tipIndex] + "</center>";
}



 /*JS File: ../js/misc/help/about.js*/ 


 Ax.About = function(){
//Ax.gs(6);

var aboutWindow = new Ext.Window({
    closable: true,
	iconCls: "tb_about",
    width: 410,
    height: 300,
    minimizable: true,
	title: "About Ajax Animator",
    border: false,
    plain: true,
    layout: 'border',
    buttons: [{
        text: 'Close',
        iconCls: "close",
        handler: function(){
            aboutWindow.close();
        }
    }],
    items: [{
	region: "north",
	baseCls: "ajaxanimator_logo",
	height: 70
	},{
	xtype: "tabpanel",
    region: 'center',
    margins: '3 3 3 0', 
    activeTab: 0,
    defaults: {autoScroll:true},
 
    items:[{
        title: 'Version',
		html: "<b>Ajax Animator "+Ax.v.release+"</b>"+"<br />"+
    "App Name: "+Ax.v.app+"<br />"+
		"Release: "+Ax.v.release+"<br />"+
    "Stability: "+Ax.v.stability+"<br />"+
		"Build: "+Ax.v.build+"<br />"+
    "Format revision: "+Ax.format.revision+"<br />"+
    "Format Revision Support: "+Ax.format.support.min + " - "+Ax.format.support.max+"<br />"+
    "Graphic Editor: "+Ax.onlypaths.version+"<br />"+
		"Testing: "+Ax.v.dev+"<br />"+
		"Release Date: "+Date.parseDate(Math.round(Ax.v.date),"U")+" ("+Ax.v.date+")<br />"+
		""
    },{
        title: 'Credits',
        html: '<b>Developers</b><br />'+
		'Antimatter15<br />'+
		"<b>Documentation</b><br />"+
		"Antimatter15<br />"+
		"Bruce Wainer (Brwainer) - Manual<br />"+
		"RandomProductions - FAQ<br />"+		
		"<b>Libraries/Extensions</b><br />"+
		'<i>Note: This is not a fully comprehensive list of everything used</i><br />'+
		'Ext v2.1 (http://extjs.com)<br />'+
		'Ext 2.x themes by Galdaka, J.C., madrabaz, and elyxr<br />'+
		'Ext.ux.ToastWindow by efattal<br />'+
		'Ext.ux.Crypto by vtswingkid<br />'+
		'<b>Patches/Bugfixes</b><br />'+
		'http://extjs.com/forum/showthread.php?p=146135<br />'+
		'http://outroot.com/extjs/bug1/<br />'+ 
		'<b>Images/Icons</b><br />'+
		'Logo by Antimatter15<br />'+
		'Icons from silk by famfamfam<br />'+
		'Icons from richdraw by Mark Finkle<br />'+
		'Loading icon from ajaxload.info<br />'+
    '<b>VectorEditor</b><br />'+
    'Raphael by Dmitry Baranovskiy<br />'+
    'Editor by Antimatter15<br />'+
    '<b>OnlyPaths</b><br />'+
    'Icons from OnlyPaths by josep_ssv<br />'+
    'OnlyPaths by josep_ssv<br />'+
    'RichDraw by Mark Finkle<br />'+
    'Sylvester by James Coglan<br />'
    },{
	title: "Special Thanks",
	html: "<b>Organizations</b><br />"+
	"liveswifers.org for their supportive community, and helping this project get started<br />"+
	"110mb.com hosting, for their reliability, cost (none), and helpful community<br />"+
	"Google Code for svn and project hosting - and just being awesome<br />"+
	"Extjs.com forums for excellent support<br />"+
	"<b>People</b><br />"+
	"inportb from 110mb forums for commentary<br />"+
	"brwainer from liveswifers.org for initial documentation, ideas, and suggestions<br />"+
	"BenjaminJ from liveswifers.org for support and ideas<br />"+
	"Brent Clancy (brclancy111/liveswif-050) for base login system<br />"+
	"RandomProductions for suggestions, fonts, and ideas<br />"+
	"OutOfLine for nice comments and motivation<br />"+
	"shanep for creating a forum for the project on liveswifers forums<br />"+
	""
	},{
		title: 'License',
		//autoLoad: "gpl-3.0-standalone.html"
		html: "GPL v3 (http://www.gnu.org/licenses/gpl-3.0.txt) <br /><br />"+Ax.gpl+" <br /><br /><i>Please don't sue me</i>"
	},{
    title: "Other",
    html: "Code: <a href='http://code.google.com/p/ajaxanimator'>http://code.google.com/p/ajaxanimator</a> "+
    "(It may be quite dated, this version that you are using right now at the time of writing has not yet been published"+
    " but the modifications to the overall codebase are relatively minor).<br /><br />I really feel old writing this right now"+
    " I probably don't need to write this, but I feel like putting some words on top of the first time I've updated this project "+
    "which is really quite magical in my mind, being older than any other project of mine. I started thinking of doing this"+
    " project back in late 2006, while I only wrote code starting at about March of 2007. I was 12 at the time. Until mid-2008, "+
    " a lot had changed. It switched from being a raw idea to a UI sketch to a bunch of lossely coupled components, basic animation,"+
    " 2 rewrites and a new core graphics editor. For almost a year, the project lay abandoned, and I had no urge to update it after "+
    " it's relative complexity and several OS switches and rejection. Finally, I updated it, which brings it up to where it is today. "+
    "While it is still lacking many features I and many users would like, I can't really do it all. I can't draw, and I can't really "+
    "make sense with making a project which I can't personally benefit any more from. I started in 2006 when my Flash MX trial ran out "+
    "and piracy felt wrong. I wanted a simple tool which could tween and draw stick figures, and it brought me along this 3 year journey."+
    "<hr> I felt pretty old writing that two years ago. Right now, it's the new years eve - the beginning of 2012. This has always been "+
    "the one project which I would use to prove that I had done something with my life. It's one of the first things I've ever done, and "+
    "remains the one that I'm probably most proud of. Most importantly of all, this is a story of visions and of ideas. What would I have "+
    "thought those five years ago, looking at something marginally refined over the eternity which would have since passed? What would "+
    "I have envisioned for a solitary musing into the development of creative software - not for professionals, mind you, but for the "+
    "limitless naivete of students. But to a sixth grader, none of that made any difference. Professional and amateur was united in a "+
    "singular appreciation for the craft and it was a vision which equalized everything. This project shifted from a means to an end, "+
    "the cleansing of a guilty conscience of software piracy and the ulterior need to pursue an artistic desire into an end in itself."+
    " It became a duty, just like that of expressing notions of society from that fifth grade perspective to create software so that "+
    "posterity may succeed in what I couldn't. But education is all about digging yourself into a hole, losing sight of the grandeur "+
    "which was a flat landscape stretching into the distance filled with magnificent and seemingly bottomless trenches and tunnels. "+
    "You can pick a nice region and start digging. You can make it your home, something warm with a barrier against the cold weather "+
    "of idiocy. In this sense, I tried to be an artist but after shoveling knee-deep into the soft soil next to a tree with sticks and"+
    " spoons, I had this marvel taken away by a higher power-- Adobe, or in real life, the administration of my Elementary school which "+
    "deemed such a giant hole as a security and safety risk near the playground (actual story turned metaphor for another actual story, "+
    "pretty cool right?). I went elsewhere to find another way to that end, but got lost in the process. Now I'm further away from the "+
    "original goal than ever and I have no regrets. Sometimes I wonder what it would be like if things turned out differently, especially "+
    "at these nostalgic times of the year.<br><br>It's been two years since the last release. A lot has changed since then and a lot hasn't. "+
    "The most relevant is probably the death of Google Wave, which is scheduled for tomorrow. Google Wave, which in a few years won't be "+
    "even part of a vague memory of humankind, was an amazing idea for the future. It, to those who allegedly grasped its sublimity was "+
    "a definite harbinger for the world to come. A sort of retro-futuristic utopia of synergy and buzzwords galore filled with ideas of"+
    " an age rendered impractical by the society and technology of its time. It was slow, clunky and didn't scale well. It promised "+
    "everything and gave us nothing but cynicism for bold notions. Regardless, I was one of the naive few who saw through the noise and "+
    "took a risk, reviving the already rotting carcass of this project under a new light. I saw no challenge as unsurmountable, and wrote "+
    " a new graphics editor: jsvectoreditor, based off a new abstraction library called Raphael. I saw Internet Explorer as a roadblock "+
    "which could be conquered, and felt that if Wave invested the effort and managed to get IE to work, so should mine. I developed a new "+
    "data persistence layer so that sketches could be collaborated on in real time. The first sign that my vision was crumbling came with "+
    "the announcement that Google Wave would no longer support IE. The wave client was sluggish and couldn't cope with the large "+
    "amounts of data which this extension generated (On a tangent, I made a wave extension called Tsunami which caused waves to crash"+
    " based on this principle and managed to pique the interest of the one and only xkcd). The vision came crashing down a bit over "+
    "a year ago when the Wave project was cancelled wholesale. The rest of the world had abandoned Wave by then, but I was one of the"+
    " reluctant few to cling on until the last dying gasp. This project stands now as a mere shell of what it was and could be. It "+
    "should be clear to all by now that I'm not the right person to maintain this. But nonetheless, even though this project is now"+
    " essentially a zombie devoid of meaning, I shall continue to exploit these naive and long gone ideals for personal benefit by "+
    "pushing the occasional update to mock its demise. I'll pretend that the ideas are still alive and well and hopefully, maybe one"+
    " day, I'll be able to convince myself that they are." 
    }]
}]
});
 
aboutWindow.on('minimize', function(){
    aboutWindow.toggleCollapse();
});

aboutWindow.show();
}

Ax.gpl = 
"This program is free software: you can redistribute it and/or modify"+"<br />"+
"it under the terms of the GNU General Public License as published by"+"<br />"+
"the Free Software Foundation, either version 3 of the License, or"+"<br />"+
"(at your option) any later version."+"<br />"+
"<br /><br />"+
"This program is distributed in the hope that it will be useful,"+"<br />"+
"but WITHOUT ANY WARRANTY; without even the implied warranty of"+"<br />"+
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"+"<br />"+
"GNU General Public License for more details."+"<br />"+
"<br /><br />"+
"You should have received a copy of the GNU General Public License"+"<br />"+
"along with this program.  If not, see http://www.gnu.org/licenses/.";




 /*JS File: ../js/misc/help/help.js*/ 


 Ax.keys = { //An object with the key arrays that will be generated and converted into something user-readable

  "F5": "Insert Frame",
  "Shift+F5": "Delete Frame",
  "F6": "To Keyframe",
  "F7": "Empty Frame",
  "Enter": "Preview/Play",
  "Page Up": "Go to Previous Frame",
  "Page Down": "Go to Next frame",
  "Delete":"Delete Selection",
  "Ctrl+C": "Copy",
  "Ctrl+X": "Cut",
  "Ctrl+V": "Paste",
  "S": "Select",
  "E": "Ellipse",
  "P": "Path",
  "G": "Polygon",
  //"I": "Image",
  //"T": "Text",
  "L": "Line",
  "R": "Rectangle"
  //this version has no such thing as undo, as with saving memory and preserving the "Google Wave" way
  //,
  //"Ctrl+Z": "Undo",
  //"Ctrl+Shift+Z": "Redo"
}
//..... hey.... wait.... what? I can read this.... Does this mean I'm not human?

Ax.keyGuide = function(){ //magickallyawesome function
//Ax.gs(5); //report user statistics
var generatedguide = "";
for(var x in Ax.keys){ //generate the magical human-readable stuff
  generatedguide += "<b>"+x+"</b> "+Ax.keys[x]+"<br>";
}
//oh wait... is it not human readable already? am i not human?
Ext.MessageBox.alert("Keyboard Shortcuts",generatedguide)
}





 /*JS File: ../js/misc/help/docs.js*/ 


 /*
Documentation (FAQ, Manual, Etc.)
*/

Ax.loadTab = function(object){
Ax.viewport.findById("maintabpanel").add(object).show()
}

Ax.loadFAQ = function(){
Ax.loadTab({xtype: "faq"})
//Ax.gs(2);
}
Ax.loadManual = function(){
Ax.loadTab({xtype: "manual"})
//Ax.gs(3);
}

Ax.loadAdvanced = function(){
Ax.loadTab({xtype: "advanced"})
//Ax.gs(3);
}


Ax.FAQ = Ext.extend(Ext.Panel,{
initComponent: function(){
Ext.apply(this,{
	title: "FAQ",

	closable: true,
	iconCls: "tb_docs",
	layout: "fit",
	border: false,
	items: {
	title: "FAQ",
	border: true,
		cls: "docs",
	iconCls: "tb_docs",
	bodyStyle: "overflow: auto;",
	//autoLoad: {
	//	url: Ax.files.faq
	//}
  //html: "FAK"
  html: '<iframe src="http://antimatter15.com/ajaxanimator/server/doc/faq.htm" border="0" style="border:none;top: 0;left:0;width:100%;height:100%;"></iframe>'
	
  
	}
	
  })
   Ax.FAQ.superclass.initComponent.apply(this, arguments);
  }
  })
  
Ext.reg("faq",Ax.FAQ)

Ax.Manual = Ext.extend(Ext.Panel,{
initComponent: function(){
Ext.apply(this,{
	title: "Manual",
	closable: true,
	iconCls: "tb_docs",
	layout: "fit",
	border: false,
	items: {
	title: "Manual",
	border: true,
	iconCls: "tb_docs",
	cls: "docs",
	//autoLoad: {
	//	url: Ax.files.manual
	//}
  html: '<iframe src="http://brwainer.110mb.com/ajaxanimator/manual/index.php" border="0" style="border:none;top: 0;left:0;width:100%;height:100%;"></iframe>'
	}
	
  })

   Ax.Manual.superclass.initComponent.apply(this, arguments);
  }
  })
  
Ext.reg("manual",Ax.Manual)


Ax.Advanced = Ext.extend(Ext.Panel,{
initComponent: function(){
Ext.apply(this,{
	title: "Advanced",
	closable: true,
	iconCls: "tb_docs",
	layout: "fit",
	border: false,
	items: {
	title: "Advanced",
	border: true,
	iconCls: "tb_docs",
	cls: "docs",
  html: '<iframe src="http://antimatter15.com/ajaxanimator/advanced.html" border="0" style="border:none;top: 0;left:0;width:100%;height:100%;"></iframe>'
	}
	
  })

   Ax.Advanced.superclass.initComponent.apply(this, arguments);
  }
  })
  
Ext.reg("advanced",Ax.Advanced)



 /*JS File: ../js/misc/help/bugs.js*/ 


 Ax.BugReport = function(){
	return Ax.msg("Not Available","This feature is not available");
	
//Ax.gs(4);
var ErrorWindow = new Ext.Window({
    closable: true,
    width: 410,
    height: 300,
    minimizable: true,
	  title: "Report Bug",
    border: false,
    plain: true,
    layout: 'border',
    buttons: [
	
	{
        text: 'Cancel',
        handler: function(){
            ErrorWindow.close();
        }
    },{
		text: 'Send (recomended)',
		handler: function(){
			Ax.msg("Sending Bug Report","We are sending your bug report... Or at least we'll make you think we are.");
			ErrorWindow.close();
		}
	}
	
	],
    items: [{
	split: true,
	height: 80,
	region: "north",
	html: "Hai"
	},{
	region: "center",
	html: "scarey"
}]
});
 
ErrorWindow.on('minimize', function(){
    ErrorWindow.toggleCollapse();
});

ErrorWindow.show();
}


//onerror = Ax.Error

Ax.comment = function(){
Ax.msg("Not Available","This feature is not available");
}

Ax.donate = function(){
Ext.MessageBox.alert("Helping the Ajax Animator","If you enjoy using the Ajax Animator and would like to help assist the project, please use the ad-supported version, report bugs, comment on desired features and spread the word.");
}



 /*JS File: ../js/misc/help/tutorials.js*/ 


 /**
 * @author Kevin
 */

Ax.tutorials_unavailable = function(){
	Ext.MessageBox.alert("Interactive Tutorials Unavaliable","Sorry, this feature is not finished yet.")
}



 /*JS File: ../js/misc/help/tipdata.js*/ 


 Ax.tips_array = [//do not mind this poopy!

"Double click on the bar between the canvas and the timeline to hide the timeline."
,
"If the canvas starts to act awkwardly or fails to work at all, head over to <b>Tools->Recovery->Reload Canvas</b> and Ajax Animator will automatically try to restart the component. Don't worry, it captures the state of your current canvas and restores, so no work will be lost."
,
"If you ever experience problems in random components, you can try reloading the animation. From the <b>Tools->Recovery</b> menu, press the <b>Reload Animation</b> button, and it'll try to rescue your project from the evils of buggy-land."
,
"In the animation browser, or inside preview, you can press <b>Play</b> multiple times for faster playback. Be sure to press <b>Pause/Stop</b> multiple times before going to another tab though!"
,
"To make the paths you draw look more fluid, set the <b>Snapping Grid</b> (in the toolbox) to <b>1px</b>. It also gives you greater percision in control over shapes, but makes it harder to create any two shapes that are exactly the same size."
,
"You can quickly convert a frame to a keyframe by right-clicking on it in the <b>timeline</b> and selecting <b>To Keyframe</b> from the context menu."
,
"The text based format used by ajax animator can almost be modified by hand. It is really not too complex."
,
"Publish (Export) to Processing, Silverlight and the Ajax Animator File Format can work offline."
,
"The application is keyboard enabled. You can use common keystroke combinations to do various actions. Go to <b>Help->Keyboard Shortcuts</b> for details"
,
"You can tween almost any attribute of any shape, from stroke thickness, location, size, color, and opacity."
,
"Click on the <b>Zoom</b> label on the canvas to reset the zoom to 100% (Default)"
,
"If you are working on a big animation project and it causes Ajax Animator to run slow, try splitting it up to smaller scenes."
,
"The informal grey boxes that appear occasionally can be removed simply by clicking on them."
] //dont min dis little insignifigant character


 /*JS File: ../js/misc/prefs.js*/ 


 Ax.urlprefs = Ext.urlDecode(window.location.search.substr(1));


 /*JS File: ../js/misc/server.js*/ 


 /**
 * I sorta wish I knew scriptdoc...
 * but anywho, this (for now) checks wheter the server works
 * @author Kevin
 */


//YAY! Ajax for Ajax Animator which doesn't actually really get used often
Ax.ajax = function(params){
  //btw this mirrors Ax.ajax
  function ajaxfail(){
        //console.log(err)
    //XSS TIME!
    //Ax.msg("Trying Alternate Communication","Ajax Failed. Trying Gadgets API")
    
    if(params.req_type == "checkproxy"){
      params.success({
          responseText: "working",
          alt_url: Ax.files.xsave
        })
      return;
    }
    
    if(window.gadgets && gadgets.io && gadgets.io.makeRequest){
      //woot!
      
      //Ax.msg("Gadget API found","Trying stuff")
      gadgets.io.makeRequest(Ax.files.xserv + params.url, function(e){
       //Ax.msg("Got Data",e.text)
       
       //FUCK THIS IS HACKY!
        params.success({
            responseText: e.text
          })
      }, {
          POST_DATA:  gadgets.io.encodeValues(params.params),
          METHOD: gadgets.io.MethodType.POST
        })
      
    }else{
      //oh noes!
      if(params.old_fail){
        params.old_fail()
      }
      //donno what to do now.
    }
  }
  try{
    params.old_fail = params.failure;
    params.failure = ajaxfail;
    Ext.Ajax["request"] (params)
  }catch(err){
    ajaxfail()
  }
}



Ax.testserver = function(reset){
	if(reset){
		Ax.server_working = null;
	}
    if (!Ax.server_working) {
        Ax.ajax({
            url: Ax.files.test+"?m=working",
			method: "get",
            success: function(e){
                if (e.responseText.indexOf("working") != -1) {
                    Ax.server_working = true;
                }
                else {
                    Ax.server_working = false;
                }
            },
            failure: function(){
                Ax.server_working = false;
            }
        })
    }
    return Ax.server_working;
}



 /*JS File: ../js/misc/message.js*/ 


 /*awesome little grey boxes that fall from the sky... stolen from Ext docs */

Ax.createBox = function(t, s){
        return ['<div class="msg">',
                '<div class="x-box-tl"><div class="x-box-tr"><div class="x-box-tc"></div></div></div>',
                '<div class="x-box-ml"><div class="x-box-mr"><div class="x-box-mc"><h3>', t, '</h3>', s, '</div></div></div>',
                '<div class="x-box-bl"><div class="x-box-br"><div class="x-box-bc"></div></div></div>',
                '</div>'].join('');
}
   
Ax.msg = function(title, format){
    if(!Ax.msgCt){
        Ax.msgCt = Ext.DomHelper.insertFirst(document.body, {id:'msg-div'}, true);
    }
    var s = String.format.apply(String, Array.prototype.slice.call(arguments, 1));
    var m = Ext.DomHelper.append(Ax.msgCt, {html:Ax.createBox(title, s)}, true);
    
    
    Ax.msgCt.alignTo(document, 't-t');
    
	m.on("click",function(){
		Ext.get(m).remove();
		//console.log(arguments)
	})
    m.slideIn('t').pause(10).ghost("t", {remove:true});
}

Ax.toastMsg = function(title, content, icon){
      new Ext.ux.ToastWindow({
        title: title,
        html: content,
        iconCls: (icon)?icon:'error'
      }).show(document);  
}



 /*JS File: ../js/misc/misc.js*/ 


 /*
A whole lot of random scripts
*/

/*
Ax.len = function(obj){ //really useful...
	var length;
	for(var i in obj){
		length++;
	}
	return length;
}
*/

Ax.macroExec = function(){
  (new Ext.Window({
    title: "Execute Macros/Scripts",
    iconCls: "tb_script",
    width: 300,
    height: 300,
    buttons: [{text: "Execute" , iconCls: "execute",handler: function(){
      try{
        
        output = Ext.util.JSON.encode(eval(this.ownerCt.findById("loadtext").getValue()));
      if(output.length > 140){ //tweet rule is good rule of thumb
      Ext.MessageBox.alert("Script Execution Output",
        output
      )
    }else{
      Ax.toastMsg("Script Execution Output", output, "information")
    }
      
    }catch(err){
      Ax.toastMsg("Script Execution Error", err.message)
    }
      
      }},
              {text: "Close", iconCls: "close", handler: function(){this.ownerCt.close()}}],
    layout: "border",
    items: [{
      region: "north",
      border: false,
      html: "Here, you can run scripts, hacks or any javascript code."
      },{
        region: "center",
        layout: "fit",
        border: false,
        items: {
          id: "loadtext",
          xtype: "textarea",
          style: "font-size: 9px"
        }
        }]
    })).show(document.body)
}

Ax.offline = function(){
	Ext.MessageBox.alert("Offline Functionality Not Availiable","Offline is not availiable but most of the application should operate fine while using your browser's offline feature (if available) if icons, CSS, and scripts are properly cached. While offline, some functionality that require a server will not work such as anything User/Login, browsing user animations, and publishing to Flash/GIF.")
}



 /*JS File: ../js/misc/api.js*/ 


 //creates an api for macros
/*
* concept:
* dumps all shapes on the current canvas
* loops through all shapes
* feeds into a certain function, returns processed data
*/



Ax.api = {
  loop: {
    "frame": function(macrofunc){
      var dump = Ax.dumpshapes();
      for(var i = 0; i < dump.length; i++){
        dump[i] = macrofunc(dump[i]);
      }
      Ax.deleteAll()
      //Ax.canvas.renderer.removeAll();
      Ax.loadShapes(dump);
    },
    "number": function(number,macrofunc){
      for(var i = 0; i < number; i++){
        macrofunc(i)
      }
    }
  },
  transform: {
    "translate": function(shape, x, y){
      shape.y += y;
      shape.x += x;
      return shape;
    },
    "absolute": function(shape, x, y){
      shape.y = y;
      shape.x = x;
      return shape;
    }
  },
  create: {
    shape: function(src){
      Ax.loadShape(src);
    },
    rect: function(x, y, width, height){
      Ax.loadShape({
          fill: Ax.Color.fill,
          stroke: Ax.Color.line,
          "stroke-width": Ax.Color.lineWidth,
          x: x,
          y: y,
          width: width,
          height: height
        })
      //Ax.canvas.renderer.create("rect", Ax.Color.fill, Ax.Color.line, Ax.Color.lineWidth, x, y, width, height)
    }
  }
}

Ax.exec = function(name){
  if(typeof Ax.plugins[name] == "function"){
    Ax.plugins[name]();
    Ax.autodiff();
  }else{
    Ax.toastMsg("Error!","Plugin Not Found!")
  }
}



 /*JS File: ../js/misc/plugins.js*/ 


 /*
* sample macros
* using the macro api
*/

Ax.plugins = {}

Ax.plugins["center"] = function(){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.absolute(shape,shape.left,Ax.canvasHeight/2)
  })
}


Ax.plugins["centerX"] = function(){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.absolute(shape,Ax.canvasWidth/2,shape.top)
  })
}

Ax.plugins["flip"] = function(){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.absolute(shape,shape.left,Ax.canvasHeight-shape.top)
  })
}

Ax.plugins["flipY"] = function(){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.absolute(Ax.canvasWidth-shape,shape.left,shape.top)
  })
}

Ax.plugins["Wave"] = Ax.plugins["Sine"] = function(mx,my){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.translate(shape,0,mx*Math.sin(shape.left*my))
  })
}

Ax.plugins["sinc wave"] = function(mx,my){
  Ax.api.loop.frame(function(shape){
    var val = shape.left/shape.width*my;
    return Ax.api.transform.translate(shape,0,mx*Math.sin(val)/val)
  })
}


Ax.plugins["Cosine"] = function(mx,my){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.translate(shape,0,mx*Math.cos(shape.left/shape.width*my))
  })
}

Ax.plugins["Brick Wall"] = function(sx, sy, height, width, brickheight, brickwidth){
  for(var x = 0; x < width; x++){
    for(var y = 0; y < height; y++){
      Ax.api.create.shape({
        type: "rect",
        top: sy+(y*brickheight),
        left: sx+(x*brickwidth),
        width: brickwidth,
        height: brickheight
        });
    }
  }
}




Ax.plugins["Explode"] = function(){
  Ax.api.loop.frame(function(shape){
    return Ax.api.transform.absolute(shape, Math.round(Math.random()*(Ax.canvasHeight-shape.height)), Math.round(Math.random()*(Ax.canvasWidth-shape.width)));  
  })
}

Ax.plugins["Random Shape"] = function(){
  Ax.api.create.shape({
    type: "rect",
    top: Math.random()*Ax.canvasHeight,
    left: Math.random()*Ax.canvasWidth,
    width: Math.random()*Ax.canvasHeight,
    height: Math.random()*Ax.canvasHeight,
	fillColor: "#"+Ax.toHex(Math.random()*255)+Ax.toHex(Math.random()*255)+Ax.toHex(Math.random()*255),
	lineColor: "#"+Ax.toHex(Math.random()*255)+Ax.toHex(Math.random()*255)+Ax.toHex(Math.random()*255),
	lineWidth: Math.random() * 20
  });
}

Ax.plugins_unavailable = function(){
	Ax.msg("Not Available","This feature is not available.")
}




 /*JS File: ../js/misc/keyboard.js*/ 


 Ext.onReady(function(){
  Ax.keymap = new Ext.KeyMap(document, [
    {
      key: 117, //F6
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.toKeyframe()}
    },
    {
      key: 116, //Shift+F5
      shift: true,
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.deleteFrame()}
    },
    {
      key: 116, //F5
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.insertFrame()}
    },
    {
      key: 118, //F7
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.toBlank()}
    },
    {
      key: 13, //Enter
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.controls.play()}
    },
    {
      key: 33, //Page Up
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.controls.previous()}
    },
    {
      key: 46, //Delete
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("delete1")}
    },
    {
      key: "s", //S
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("select")}
    },
    {
      key: "p", //P
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("path")}
    },/*
    {
      key: "t", //T
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("text")}
    },*/
    {
      key: "l", //L
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("line")}
    },
    {
      key: "g", //G
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("polygon")}
    },
    {
      key: "r", //R
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("rect")}
    },
    {
      key: "e", //E
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("ellipse")}
    },/*
    {
      key: "i", //I
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.setTool("image")}
    },*/
    {
      key: 34, //Page Down
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.controls.next()}
    },
    {
      key: "c", //Ctrl+C
      ctrl: true,
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.clipboard_copy()}
    },
    {
      key: "x", //Ctrl+X
      ctrl: true,
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.clipboard_cut()}
    },
    {
      key: "v", //Ctrl+V
      ctrl: true,
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.clipboard_paste()}
    }/*,
    {
      key: "z", //Ctrl+Z
      ctrl: true,
      shift: false,
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};if(event.shiftKey==false){Ax.history_undo()}}
    },
    {
      key: "z", //Ctrl+Shift+Z 
      ctrl: true,
      shift: true,
      fn: function(code, event){if(!Ax.verify_keydown(code, event)){return};Ax.history_redo()}
    }*/
  ])
  })


Ax.verify_keydown = function(code, event){ //koolio! this is sssooooooo much better than that old one! actually, come to think of it.. now it's sorta complex...

  if([116, 117, 118].indexOf(code) != -1){//if its one of the "banned" keycodes, such as F5 (reloads page), ALWAYS stop it's default behavior
    event.stopEvent();//stop default behavior
  }
  
  var selectedText;  //stolen and modified from quirksmode
  if (window.getSelection) {
    selectedText = window.getSelection().toString();
  }else if (document.selection) { //I3 suxx0rz
    selectedText = document.selection.createRange();
  }
  if(selectedText.length > 1){return} //don't continue if there's anything in the selection
  
  if(['input','textarea'].indexOf(event.getTarget().tagName.toLowerCase()) == -1){ //ignore everything if it's a text element
      event.stopEvent();//yep..
      return true; //oooo
  }
  return;
  //console.log(event);
}



 /*JS File: ../js/misc/end.js*/ 


 Ext.onReady(function(){
    setTimeout(function(){
        Ext.get('loading').remove();
        Ext.get('loading-mask').fadeOut({
            remove: true
        });
        
        setTimeout(function(){
           /*
            * moved to center.js
            * */
            /*
             * moved over to center.js
             * */
            
            //Ax.selectFrame(1, "Layer 1")
            if(Ax.wavesetup){
              Ax.wavesetup()
            }
            
            if (Ax.urlprefs.load) {
              setTimeout(function(){
                if(!window.ds){
                  window.ds = new Datastore("ajaxanimator");
                }
                ds.first(Ax.urlprefs.load, function(data){
                   Ax.autoimport(data.data);
                   Ax.msg("Auto Loaded From URL","Animation "+Ax.urlprefs.load+" has been automatically loaded.")
                })
              },100);
            }
            
            //Main Timeline initialization stuff, create, add alyer, add frames, select first one..
            
            //Ax.selectFrame(1, "Layer 1")
            //new Ext.ux.ToastWindow({delay: 1000});
			
            setTimeout(function(){
            
                //Ax.showTips();
                if (!window.developer) {
					if (Ax.v.dev) {
						//Ax.gs(1);
						/*
						new Ext.ux.ToastWindow({
							title: 'Testing Release',
							
							html: 'You are running an unstable testing release. ' +
							'It is not intended for normal use. Please report bugs and post ' +
							'comments about this release (build ' +
							Ax.v.build +
							') frequently. Happy Testing!'
						}).show(document);
            */
					}
					else {
						/*
            new Ext.ux.ToastWindow({
							title: 'Beta Release',
							delay: 10000,
							html: "There's a reason it's beta, there may be <i>a lot</i> of bugs, some more annoying than others. "+
							"So please report bugs, post comments, and be a nice person."
						}).show(document);
            */
					}
					
					if (Ext.isIE) {//you know I miss the days of saying "Error: YOUR BROWSER SUCKS!"
						//Ext.MessageBox.alert("Notes on Microsoft Internet Explorer", 
            //"Currently, support for Microsoft Internet Explorer (6/7/8) are only experimental. Some features do not work properly such as animation and playback of some specific animations. The issues are being fixed, but in the mean time, you may try out another browser such as <a href='http://getfirefox.com'>Firefox</a>, <a href='http://opera.com'>Opera</a>, or <a href='http://apple.com/safari'>Safari</a>.")
					}
					else {
						//Ax.showTips();
					}
				}
                
            }, 100)
            /*
            setTimeout(function(){
               // Ax.testserver();
                //really, this does nothing, so it shouldn't be used.
            }, 500)
			*/
        }, 150);
        
        
        
    }, 250);
})



 /*JS File: ../js/misc/formpost.js*/ 


 function autopost(posturl,params,cb) {
	// random id
	var conv = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', len = conv.length, ucb = 'ucb_';
	for(var i = 0; i < 32; i++) ucb += conv.charAt(Math.floor(Math.random()*len));
	var div = document.createElement('div');
	// container div
	div.style.display = 'none';
	
  //div.style.position = "absolute"
  //div.style.zIndex = 9999999999999999999999999999;
  document.body.appendChild(div);
  
	var iframe;
  var form = document.createElement('form');
  
	// called after POST
	window['c'+ucb] = function() {
    try{
				if(iframe.contentWindow.location =='about:blank'){ //opera and safari load about:blank
          return;
				}
			}catch(e){}
		//setTimeout(function() { if(div.parentNode) div.parentNode.removeChild(div); },0);
		cb();
    
	}
	// iframe
	try { iframe = document.createElement('<iframe id="'+ucb+'" name="'+ucb+'" onload="window.c'+ucb+'()">'); }	// IE
	catch(ex) { iframe = document.createElement('iframe'); iframe.id = iframe.name = ucb; iframe.onload = window['c'+ucb]; }	// normal
	div.appendChild(iframe);
	// form
	
	form.target = ucb;
	form.action = posturl;
	form.method = 'POST';
	div.appendChild(form);
	// submit form
	for(var key in params) {
		var input = document.createElement('input');
		input.type = 'text';
		input.name = key;
		input.value = params[key];
		form.appendChild(input);
	}
	if(window.frames[ucb].name != ucb) {
		window.frames[ucb].name = ucb;
	}
	form.submit();
}
